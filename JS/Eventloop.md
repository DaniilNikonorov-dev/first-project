![[Pasted image 20241125093222.png]]

**Event Loop** (цикл событий) в JavaScript — это механизм, который позволяет эффективно управлять асинхронными операциями, такими как запросы к серверу, таймеры или обработка событий. Он отвечает за выполнение кода, сборку и обработку событий в очереди событий (event queue) и обработку асинхронных операций.

### Основные компоненты Event Loop:

1. **Call Stack (Стек вызовов)**:
    
    - Это стек, где выполняются синхронные операции. Когда функция вызывается, она добавляется в стек вызовов. Когда выполнение функции завершено, она удаляется из стека.
2. **Callback Queue (Очередь колбеков)**:
    
    - Очередь колбеков — это очередь асинхронных операций, например, колбеков от событий или таймеров. Когда стек вызовов пуст, Event Loop извлекает и выполняет колбеки из этой очереди.
3. **Web APIs (или Browser APIs)**:
    
    - Это интерфейсы, предоставляемые браузером (или Node.js, если это серверный JavaScript). Например, таймеры (`setTimeout`, `setInterval`), обработчики событий (например, клики мышью), запросы HTTP и другие асинхронные операции. Когда такие операции завершаются, их колбеки помещаются в очередь колбеков.
4. **Event Loop (Цикл событий)**:
    
    - Это механизм, который проверяет стек вызовов и очередь колбеков. Если стек вызовов пуст, Event Loop извлекает первый элемент из очереди и помещает его в стек для выполнения.

### Как работает Event Loop:

1. Когда код выполняется, синхронные операции выполняются первым делом и добавляются в стек вызовов.
2. Когда выполняются асинхронные операции (например, запросы, таймеры), они обрабатываются в Web APIs, и их колбеки (функции обратного вызова) помещаются в очередь колбеков.
3. Когда стек вызовов пуст, Event Loop извлекает колбек из очереди и выполняет его.
4. Этот процесс продолжается, пока код не завершится.
### Микротаски и макротаски:

Асинхронные операции могут быть разделены на два типа задач:

- **Макротаски (Macrotasks)** — это основные задачи, такие как обработка событий, выполнение таймеров, запросов HTTP и т. д.
- **Микротаски (Microtasks)** — это задачи с более высоким приоритетом, такие как промисы (Promise) и `MutationObserver`.

Микротаски выполняются перед макротасками, даже если очередь макротасков не пуста.



### 1. **Событийный цикл (Event Loop)**

Событийный цикл — это механизм, который позволяет JavaScript выполнять асинхронные операции (например, запросы к серверу или таймеры), не блокируя основной поток выполнения (первичный поток).

JavaScript выполняет код синхронно, но операции, которые требуют времени (например, чтение файла или запрос к серверу), обрабатываются асинхронно, чтобы не блокировать выполнение остальных операций.

Событийный цикл позволяет асинхронному коду (например, callback-функциям или обработчикам событий) ставиться в очередь на выполнение, и он будет выполняться после того, как основной поток завершит все текущие операции.

### 2. **Callbacks**

**Callback** — это функция, которая передается в другую функцию как аргумент и вызывается после завершения какой-либо операции. Это один из первых подходов для работы с асинхронным кодом в JavaScript.


`function fetchData(callback) {`
    `setTimeout(() => {`
        `callback('Data loaded');`
    `}, 1000);`
`}`

`fetchData(function(result) {`
    `console.log(result);  // Выведет 'Data loaded' через 1 секунду`
`});`

### 3. **Promises**

**Promise** — это объект, который представляет собой промежуточный результат асинхронной операции и позволяет работать с результатами этой операции позже. Он может быть в одном из трех состояний:

- **Pending** — ожидание результата.
- **Fulfilled** — операция завершена успешно.
- **Rejected** — операция завершена с ошибкой.

Promise решает проблему вложенных callback’ов (callback hell).

Пример использования Promise:

`function fetchData() {`
    `return new Promise((resolve, reject) => {`
        `setTimeout(() => {`
            `resolve('Data loaded');`
        `}, 1000);`
    `});`
`}`

`fetchData()`
    `.then(result => console.log(result))  // 'Data loaded'`
    `.catch(error => console.log(error));`


Сразу заметно несколько преимуществ перед подходом с использованием колбэков:

|Промисы|Колбэки|
|---|---|
|Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем `loadScript(script)`, и затем (`.then`) мы пишем, что делать с результатом.|У нас должна быть функция`callback` на момент вызова `loadScript(script, callback)`. Другими словами, нам нужно знать что делать с результатом _до того_, как вызовется `loadScript`.|
|Мы можем вызывать `.then` у `Promise` столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок». Больше об этом в следующей главе: [Цепочка промисов](https://learn.javascript.ru/promise-chaining).|Колбэк может быть только один.|


### 4. **async/await**

**async/await** — это синтаксический сахар, который позволяет писать асинхронный код в стиле синхронного. `async` делает функцию асинхронной, а `await` позволяет "подождать" завершения Promise, не блокируя выполнения остальной части кода.

Пример использования async/await:


`async function fetchData() {`
    `const result = await new Promise((resolve, reject) => {`
        `setTimeout(() => {`
            `resolve('Data loaded');`
        `}, 1000);`
    `});`
    `console.log(result);`
`}`

`fetchData();  // 'Data loaded'`


В этом примере код выглядит как синхронный, но на самом деле он работает асинхронно, ожидая выполнения Promise с помощью `await`.

### Сравнение:

- **Callback**: прост, но может привести к сложному и трудному для чтения коду (особенно при множественных вложенных callback’ах).
- **Promises**: более читаемы и удобны в работе с асинхронным кодом, позволяет избегать "callback hell".
- **Async/await**: самый удобный и читаемый синтаксис для работы с асинхронным кодом, делает код похожим на синхронный.


### Заключение:

Event Loop позволяет JavaScript эффективно управлять асинхронными операциями, при этом не блокируя основной поток выполнения. Он работает в цикле, обрабатывая сначала синхронные задачи, затем микротаски, и только потом макротаски, что гарантирует, что операции с высоким приоритетом, такие как промисы, будут выполнены как можно быстрее.
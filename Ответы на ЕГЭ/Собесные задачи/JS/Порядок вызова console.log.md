#### 1. В каком порядке выведутся сообщения и почему?

```JS
console.log(1)
  
setTimeout(function() {
  console.log(2)
})
  
Promise.resolve(3).then(console.log)
  
console.log(4)
  
setTimeout(function() {
  console.log(5)
}, 0)
  
console.log(6)
  
// Запишите, в каком порядке значения выведутся в консоль:
//
```

##### Решение
1. 1 4 6 3 2 5
**Почему так происходит:**
1. **Синхронный код:**  
    Выполняется сразу же в порядке написания:
    
    - `console.log(1)` → выводит **1**.
    - Затем вызывается `setTimeout(function() { console.log(2) })` – функция не выполняется, а ставится в очередь макротасков.
    - Далее `Promise.resolve(3).then(console.log)` – коллбэк добавляется в очередь микротасков.
    - `console.log(4)` → выводит **4**.
    - Затем вызывается `setTimeout(function() { console.log(5) }, 0)` – функция ставится в очередь макротасков.
    - И `console.log(6)` → выводит **6**.
2. **Микротаски (Promise):**  
    После завершения всего синхронного кода движок JavaScript обрабатывает все микротаски, прежде чем переходить к макротаскам. Таким образом, вызывается коллбэк `then`, который выводит **3**.
    
3. **Макротаски (setTimeout):**  
    После обработки микротасков выполняются макротаски в порядке их регистрации:
    
    - Первый `setTimeout` выводит **2**.
    - Второй `setTimeout` выводит **5**.

#### 3. Что выведется если добавить в конец. Залогируются ли 2 и 5 и что будет с интерфейсом, будет ли реагировать на инпут.

```JS
const foo1 = () => {
  console.log('foo1')
   
  return Promise.resolve().then(foo1)
}
   
foo1(); // вызов foo1, объявленной выше
```

##### Решение
2. 1 4 6 foo1 3 foo1 foo1 foo1 ... - Интерфейс зафризится и перестанет реагировать на инпут юзера. 2 и 5 не залогируются

###### 1. происходит следующее:
    
    - При вызове foo1() синхронно выводится `'foo1'`.
    - Затем выполняется `Promise.resolve().then(foo1)`, что добавляет вызов foo1() в очередь микротасков.
    - Как только движок переходит к обработке микротасков, он вызывает foo1(), который снова выводит `'foo1'` и снова планирует новый вызов через Promise.then.
    - Таким образом, микротаски никогда не заканчиваются — они бесконечно цепляются друг за другом.
2. **Последствия:**
    
    - **Сообщения 2 и 5:**  
        Поскольку макротаски (setTimeout) не могут выполниться до тех пор, пока очередь микротасков не опустеет, а она никогда не опустеет, setTimeout колбэки (с выводом 2 и 5) так и не будут запущены.
    - **Интерфейс и реакция на инпут:**  
        Бесконечная цепочка микротасков блокирует event loop, поэтому обработка макротасков (таких как события пользовательского ввода, перерисовка интерфейса, клики и т.д.) не происходит. Интерфейс зависнет и не будет реагировать на ввод.

**Вывод:**  
После добавления вызова foo1():

- Будет бесконечно выводиться `'foo1'` (на самом деле, они будут вызываться без паузы).
- Сообщения 2 и 5 (из setTimeout) **не будут залогированы**.
- Интерфейс заблокируется, и пользовательский ввод не будет обрабатываться.


#### 1. Что если заменить зацикливание промисов на таймауты

```JS
const foo2 = () => {
  console.log('foo2')
   
  setTimeout(foo2);
}
  
foo2(); // вызов foo2, объявленной выше
```

3. 1 4 6 foo2 3 2 5 foo2 foo2 ... - Интерфейс будет реагировать на инпут юзера, интерфейс не зафризится

При использовании таймаутов, а не зацикленного Promise, функция будет вызываться рекурсивно, но каждый вызов планируется как отдельная макротаска. Это означает:
- **Поведение интерфейса:**  
    Так как каждый вызов через `setTimeout` ставится в очередь макротасков, event loop получает возможность обрабатывать другие события между вызовами функции. Это означает, что UI останется отзывчивым, и обработка пользовательских событий, перерисовка и прочее будет происходить корректно.  
    В отличие от бесконечной цепочки микротасков (как в случае с промисами), которая не дает event loop «отдохнуть», рекурсия через `setTimeout` позволяет браузеру вставлять промежутки для обновления интерфейса.
    

Таким образом, замена зацикливания промисов на таймауты приводит к тому, что функция выполняется циклически, выводя `"foo2"`, но не блокирует интерфейс, так как между вызовами предоставляется время для обработки других задач.
# RxJS

## Observable

### 1. Что такое Observable? 
Компонент реактивного программирования. Представляет собой поток данных, который может быть синк и асинк. Операторы Observable поддерживают трансормацию данных через такие операторы, как map, filter, mergeMap. Его можно использовать с разными подписчиками. 
Используется в реактивных формах, запросах, можно превратить события в Obs
Пример использования `Observable` в Angular
#### Сервис:

```TS
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class UserService {
  constructor(private http: HttpClient) {}

  getUsers(): Observable<any[]> {
    return this.http.get<any[]>('https://jsonplaceholder.typicode.com/users');
  }
}
```
Компонент
```TS
import { Component, OnInit } from '@angular/core';
import { UserService } from './user.service';

@Component({
  selector: 'app-user-list',
  template: `
    <div *ngIf="users$ | async as users">
      <p *ngFor="let user of users">{{ user.name }}</p>
    </div>
  `,
})
export class UserListComponent implements OnInit {
  users$ = this.userService.getUsers(); // Привязка Observable к шаблону

  constructor(private userService: UserService) {}

  ngOnInit(): void {
    this.users$.subscribe((data) => console.log('Данные пользователей:', data));
  }
}
```
#### Важные методы `Observable`

1. **`subscribe`:** Подписывается на `Observable` и обрабатывает данные, ошибки и завершение.
2. **`pipe`:** Позволяет применять операторы к потоку данных.
3. **`unsubscribe`:** Отключает подписку и предотвращает утечки памяти.
#### Особенности и рекомендации

1. **Асинхронные данные:** В Angular часто используют `AsyncPipe` (`| async`) в шаблоне, чтобы автоматически подписываться на `Observable` и отписываться при уничтожении компонента.
```HTML
<div *ngIf="data$ | async as data">
  {{ data }}
</div>
```
**Отписка:** Если вы используете ручную подписку (`subscribe`), обязательно отписывайтесь через `ngOnDestroy` или `takeUntil`:
```TS
private destroy$ = new Subject<void>();

this.observable$.pipe(takeUntil(this.destroy$)).subscribe();

ngOnDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}
```


### 2. Разница между Observable и Promise
#### 1. Разовое vs Многократное

- **Promise:**
    - Может возвращать только одно значение (или ошибку).
    - После того, как promise выполнено (resolved) или отклонено (rejected), его нельзя повторно использовать.
- **Observable:**
    - Может возвращать множество значений с течением времени.
    - Вы можете подписываться и отписываться от `Observable`, что позволяет более гибко управлять потоком данных.
#### 2. Отложенная инициализация
- **Promise:**
    - Запускается сразу при создании. Его выполнение не зависит от того, подписались ли на него или нет.
- **Observable:**
    - Инициализируется только тогда, когда на него подписались. Это позволяет избежать ненужных запросов или вычислений, если результаты не нужны.


### 3. Observable принимает обработчики next, error, complete. В чем между ними разница? Когда что использовать?

 Обработчики next, error, complete представляют собой методы, которые обрабатывают разные события, происходящие в потоке.
 
 ###### Next 
 Этот обработчик вызывается каждый раз, когда Observable отправляет новое значение.
 - Используйте `next`, чтобы обрабатывать данные, когда они поступают из потока. Это может быть полезно, когда вы хотите производить действия на основе получаемых значений.

 ###### error
  используйте error, чтобы ошибки, которые могут произойти во время получения данных из потока. Если ошибка происходит - будет вызван этот обработчик

complete
Вызывается, когда Observable завершает свою работу нормальным образом и без ошибок

### 4. Что значит "завершение потока"? Какие потоки завершаются, какие нет? Завершается ли поток при ошибке? 

Завершение потока означает, что Observable завершил свое выполнение и не будет больше отправлять данные своим подписчикам. Это может произойти при срабатывании complete или при отписке всех подписчиков методом unsubscribe.

Однако, стоит помнить, что завершение потока =  что поток более не отправляет данные из источника данных и метод unsab не всегда останавливает поток.
Пример:
```TS
function cusomTimer(time: number){
  return new Observable(sub => {
    let i=0
    const timeId = setInterval (() => {
      sub.next(i++)
    },time)
    return() => {
      clearInterval(timeId)
    }
  })
}
```
##### Когда потоки завершаются

1. **Автоматическое завершение**  
    Observable завершается автоматически, когда:
    
    - Он эмитирует фиксированное количество значений (например, с использованием `of` или `range`).
    - Его определение явно завершает поток после определённого условия.
```TS
import { of } from 'rxjs';

of(1, 2, 3).subscribe({
  next: value => console.log('Значение:', value),
  complete: () => console.log('Поток завершён')
});
// Вывод:
// Значение: 1
// Значение: 2
// Значение: 3
// Поток завершён

```

**Завершение по условию**  
Observable завершается при использовании операторов, которые ограничивают количество эмиссий:

- `take(n)`: Завершает поток после эмиссии `n` значений.
- `first`: Завершает поток после первого значения.
- `last`: Завершает поток, выдав последнее значение.
```TS
import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

interval(1000).pipe(take(3)).subscribe({
  next: value => console.log('Значение:', value),
  complete: () => console.log('Поток завершён')
});
// Вывод (каждую секунду):
// Значение: 0
// Значение: 1
// Значение: 2
// Поток завершён

```

**HTTP-запросы (завершаются автоматически)**  
HTTP-запросы с помощью `HttpClient` завершаются после получения ответа.
```TS
this.http.get('https://api.example.com/data').subscribe({
  next: data => console.log('Данные:', data),
  complete: () => console.log('HTTP-запрос завершён')
});
```

### 5. Какие Api в Ангуляре используют Observable
Самые наиболее частые API, которые используются это: 

###### HttpClient 
Это позволяет подписываться на результаты запросов и обрабатывать их асинхронно.
```TS
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core'; 
import { Observable } from 'rxjs'; 
@Injectable({ providedIn: 'root', }) 
	export class DataService { 
		constructor(private http: HttpClient) {} 
		getData(): Observable<any> { 
			return this.http.get('https://api.example.com/data'); } }
```

###### Router
Angular Router использует `Observable` для отслеживания состояния маршрутов и параметров. Например, `ActivatedRoute` предоставляет `params` и `queryParams` как `Observable`, что позволяет подписываться на изменения в маршруте.

```TS
import { Component, EventEmitter, Output } from '@angular/core';

@Component({ 
selector: 'app-my-component', 
template: '<button (click)="emitEvent()">Click me!</button>', 
})

export class MyComponent { 
	@Output() myEvent: EventEmitter<string> = new EventEmitter(); 

	emitEvent() { this.myEvent.emit('Hello from MyComponent!'); } }
```

###### EventEmitter

В Angular `EventEmitter` — это класс, который расширяет `Subject`, и он также возвращает `Observable`. Он часто используется для создания пользовательских событий в компонентах.

Reactive Forms
В реактивных формах Angular используются `Observable` для отслеживания изменений в значениях формы и состоянии валидности. Например, методы `valueChanges` и `statusChanges` возвращают `Observable`.

### Интерфейсы Observable и Observer в Rx

В **RxJS** (Reactive Extensions for JavaScript) основными сущностями являются **Observable** (наблюдаемый поток) и **Observer** (наблюдатель). Эти концепции основаны на паттерне "Наблюдатель" (Observer Pattern) и используются для работы с асинхронными потоками данных.

##### **Observable (Наблюдаемый)**

**`Observable`** – это источник данных, который может отправлять значения (события) подписчикам (наблюдателям). Он представляет поток значений, который может быть конечным или бесконечным.
Пример создания **Observable**:
```TS
import { Observable } from 'rxjs';

const observable = new Observable<number>((subscriber) => {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  subscriber.complete(); // Завершает поток
});
```

🔹 Основные методы **Observable**:

- `next(value)`: отправляет следующее значение подписчикам;
- `error(error)`: сообщает об ошибке и завершает поток;
- `complete()`: завершает поток.

##### **Observer (Наблюдатель)**

**`Observer`** – это объект, который подписывается на **Observable** и реагирует на его события.

Observer должен содержать 3 метода:
- **`next(value)`** – вызывается, когда **Observable** отправляет значение.
- **`error(error)`** – вызывается, если произошла ошибка.
- **`complete()`** – вызывается, когда поток завершается.

Пример **Observer**:
```TS
const observer = {
  next: (value: number) => console.log('Получено:', value),
  error: (err: any) => console.error('Ошибка:', err),
  complete: () => console.log('Поток завершён')
};
```

Подписка **Observer** на **Observable**:
```TS
observable.subscribe(observer);
```

✅ **Итог**: **Observable** – это поток данных, **Observer** – подписчик, который реагирует на события потока.


### Для чего нужно отписываться от потока и как это можно сделать?
#### ❓ Почему важно отписываться?

RxJS-стримы могут работать бесконечно (например, `interval` или события DOM). Если не отписываться, утечки памяти неизбежны, так как поток остаётся активным, даже если компонент удалён.

Когда вы подписываетесь на поток данных (например, через `Observable` или `Subject`), если вы не отписываетесь от него, Angular продолжит хранить подписку, даже если компонент был уничтожен, что может привести к утечке памяти.

#### ngOndestroy
**Вручную через `ngOnDestroy`:** В `ngOnDestroy` можно отписаться от всех подписок. Пример:
```TS
import { Component, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs';
import { DataService } from './data.service';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html'
})
export class ExampleComponent implements OnDestroy {
  private subscription: Subscription;

  constructor(private dataService: DataService) {
    this.subscription = this.dataService.getData().subscribe(data => {
      console.log(data);
    });
  }

  ngOnDestroy(): void {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
}
```

#### takeUntil
**Использование `takeUntil`:** Этот оператор позволяет автоматически завершить подписку, когда другой поток сигнализирует об этом. Обычно используется для отписки при уничтожении компонента:
```TS
import { Component, OnDestroy } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { DataService } from './data.service';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html'
})
export class ExampleComponent implements OnDestroy {
  private destroy$ = new Subject<void>();

  constructor(private dataService: DataService) {
    this.dataService.getData()
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => {
        console.log(data);
      });
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

#### AsyncPipe
**Использование `AsyncPipe`:** Если поток используется в шаблоне, можно воспользоваться `AsyncPipe`, который автоматически управляет подписками. Например:
```HTML
<div *ngIf="dataService.getData() | async as data">
  {{ data }}
</div>
```

### Горячий и холодные потоки. Как подогреть поток?
#### **Горячий поток (Hot Observable)**

Горячий поток **не создаёт новый источник данных** для каждого подписчика. Все подписчики получают **одинаковые** значения.

Пример горячего Observable:
```TS
import { interval, share } from 'rxjs';

const hot$ = interval(1000).pipe(share());

hot$.subscribe(value => console.log('Подписчик 1:', value));

setTimeout(() => {
  hot$.subscribe(value => console.log('Подписчик 2:', value));
}, 3000);
```

Вывод в консоль:
```yaml
Подписчик 1: 0
Подписчик 1: 1
Подписчик 1: 2
Подписчик 2: 3
Подписчик 1: 3
```
**Подписчик 2** подключился на **третьей секунде** и получил **актуальные данные**, а не начинал заново

#### **Холодный поток (Cold Observable)**

Холодные потоки создают **новый** поток данных **для каждого подписчика**.

Пример холодного Observable:
```TS
import { Observable } from 'rxjs';

const cold$ = new Observable(observer => {
  console.log('Запуск потока');
  observer.next(Math.random());
});

cold$.subscribe(value => console.log('Подписчик 1:', value));
cold$.subscribe(value => console.log('Подписчик 2:', value));
```
Вывод в консоль:
```yaml
Запуск потока
Подписчик 1: 0.1234
Запуск потока
Подписчик 2: 0.5678
```
Каждый подписчик получает **разные** значения, потому что создаётся **новый поток**.

#### 🔥 Как "подогреть" холодный поток?

Чтобы сделать **холодный поток горячим**, можно использовать:

- **`share()`** – делит поток между подписчиками.
- **`publish()` + `connect()`** – вручную управляет подпиской.
- **`Subject`** – используется как прокси.

Пример с **`Subject`**:
```TS
import { Subject, interval } from 'rxjs';

const subject = new Subject<number>();

interval(1000).subscribe(subject); // Прокидываем данные в subject

subject.subscribe(value => console.log('Подписчик 1:', value));

setTimeout(() => {
  subject.subscribe(value => console.log('Подписчик 2:', value));
}, 3000);
```

#### 🔥 **Горячий поток с `share()`**

Чтобы все подписчики **разделяли один поток**, используем `share()`:
```TS
import { interval, take, share } from 'rxjs';

// Интервал каждую секунду (берём 5 значений и завершаем поток)
const hot$ = interval(1000).pipe(
  take(5),  // Ограничиваем поток 5 значениями
  share()   // Делаем поток горячим
);

hot$.subscribe(value => console.log('Подписчик 1 получил:', value));

setTimeout(() => {
  hot$.subscribe(value => console.log('Подписчик 2 получил:', value));
}, 2000); // Подключаем второго подписчика через 2 секунды
```





## Операторы и использование

#### 1. Какие Api в Ангуляре используют Observable?
Самые наиболее частые API, которые используются это: 

###### HttpClient 
Это позволяет подписываться на результаты запросов и обрабатывать их асинхронно.
```TS
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core'; 
import { Observable } from 'rxjs'; 
@Injectable({ providedIn: 'root', }) 
export class DataService { constructor(private http: HttpClient) {} getData(): Observable<any> { return this.http.get('https://api.example.com/data'); } }
```

###### Router
Angular Router использует `Observable` для отслеживания состояния маршрутов и параметров. Например, `ActivatedRoute` предоставляет `params` и `queryParams` как `Observable`, что позволяет подписываться на изменения в маршруте.

```TS
import { Component, EventEmitter, Output } from '@angular/core';

@Component({ 
selector: 'app-my-component', 
template: '<button (click)="emitEvent()">Click me!</button>', 
})

export class MyComponent { 
	@Output() myEvent: EventEmitter<string> = new EventEmitter(); 

	emitEvent() { this.myEvent.emit('Hello from MyComponent!'); } }
```

###### EventEmitter

В Angular `EventEmitter` — это класс, который расширяет `Subject`, и он также возвращает `Observable`. Он часто используется для создания пользовательских событий в компонентах.

Reactive Forms
В реактивных формах Angular используются `Observable` для отслеживания изменений в значениях формы и состоянии валидности. Например, методы `valueChanges` и `statusChanges` возвращают `Observable`.
#### 2. Что такое оператор? Ваши самые частые операторы в rxjs.
В контексте RxJS оператор — это функция, которая принимает `Observable` в качестве входных данных и возвращает новый `Observable`. Операторы позволяют обрабатывать, трансформировать и управлять потоками данных, а также комбинировать несколько потоков вместе.
##### Классификации операторов
Операторы делятся на два основных типа:

1. **Pipeable Operators (Операторы для `pipe`)**  
    Используются внутри метода `.pipe()` для обработки данных в потоке. Пример: `map`, `filter`, `mergeMap`.
    
2. **Creation Operators (Операторы создания)**  
    Эти операторы создают `Observable`.  
    Пример: `of`, `from`, `interval`.

##### Примеры
###### **1. Операторы трансформации (Transformation Operators)**

Используются для изменения данных в потоке.

| Оператор    | Описание                                                             |
| ----------- | -------------------------------------------------------------------- |
| `map`       | Преобразует каждый элемент потока.                                   |
| `mergeMap`  | Плоское объединение (flatMap), разворачивает вложенные `Observable`. |
| `switchMap` | Переключает на новый поток, отменяя предыдущий.                      |
| `concatMap` | Обрабатывает элементы по очереди, сохраняя порядок.                  |
| `scan`      | Накопление данных (аналог `reduce`).                                 |
```TS
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

of(1, 2, 3)
  .pipe(map(x => x * 10))
  .subscribe(console.log); // Вывод: 10, 20, 30

```

###### **2. Операторы фильтрации (Filtering Operators)**
Применяются для фильтрации элементов в потоке.

| Оператор               | Описание                                                       |
| ---------------------- | -------------------------------------------------------------- |
| `filter`               | Пропускает только те элементы, которые удовлетворяют условию.  |
| `take`                 | Берет только указанное количество элементов и завершает поток. |
| `takeUntil`            | Прекращает поток, когда другой поток выдает значение.          |
| `skip`                 | Пропускает указанное количество элементов в начале потока.     |
| `distinctUntilChanged` | Пропускает только уникальные последовательные значения.        |
```TS
import { of } from 'rxjs';
import { filter } from 'rxjs/operators';

of(1, 2, 3, 4, 5)
  .pipe(filter(x => x % 2 === 0))
  .subscribe(console.log); // Вывод: 2, 4

```

###### **3. Операторы комбинирования (Combination Operators)**
Объединяют несколько потоков данных.

| Оператор         | Описание                                                             |
| ---------------- | -------------------------------------------------------------------- |
| `merge`          | Объединяет несколько потоков в один.                                 |
| `concat`         | Последовательно объединяет потоки, дожидаясь завершения предыдущего. |
| `combineLatest`  | Комбинирует последние значения из нескольких потоков.                |
| `forkJoin`       | Ждет завершения всех потоков и возвращает их последние значения.     |
| `withLatestFrom` | Объединяет текущий поток с последними значениями другого потока.     |
```TS
import { combineLatest, of } from 'rxjs';

const stream1 = of('A', 'B', 'C');
const stream2 = of(1, 2, 3);

combineLatest([stream1, stream2]).subscribe(([val1, val2]) => {
  console.log(val1, val2); // Выводит: 'C', 3 (т.к. оба потока завершены)
});

```

###### 4. Операторы создания (Creation Operators)
Создают новые потоки данных.

| Оператор    | Описание                                                 |
| ----------- | -------------------------------------------------------- |
| `of`        | Создает поток из перечисленных значений.                 |
| `from`      | Преобразует массив, промис или итератор в поток.         |
| `interval`  | Генерирует числа через равные промежутки времени.        |
| `fromEvent` | Создает поток событий DOM (например, клики мыши).        |
| `timer`     | Создает поток, который запускается через заданное время. |
```TS
import { fromEvent } from 'rxjs';

const clicks$ = fromEvent(document, 'click');
clicks$.subscribe(event => console.log('Клик:', event));

```

###### **5. Операторы обработки ошибок (Error Handling Operators)**

Управляют ошибками в потоке.

| Оператор     | Описание                                                |
| ------------ | ------------------------------------------------------- |
| `catchError` | Перехватывает ошибку и возвращает альтернативный поток. |
| `retry`      | Повторяет выполнение потока при ошибке.                 |
| `retryWhen`  | Повторяет выполнение с использованием другой логики.    |
```TS
import { of, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

throwError('Ошибка!')
  .pipe(catchError(err => of(`Обработано: ${err}`)))
  .subscribe(console.log); // Вывод: "Обработано: Ошибка!"

```

#### 3. Что сделать, чтобы обработать 2 потока одной и той же функцией?
Можно объединить два поток в merge, перед этим создать функцию, которая будет их обрабатывать:
```TS
 ngOnInit(): void {
      this.load = true
      const clickStream = fromEvent(document.getElementById('Mybutton')!, 'click')
      const freeStream = interval(1000);
  const processFunction = (data: any) => {
    return `Обработано: ${data}`;
  }
  merge(

    clickStream.pipe(map(() => 'Клик!')),
    freeStream.pipe(map((count) => `Таймер: ${count}`)),timer(2000)

  )
    .pipe(map(processFunction)) // Применяем функцию к объединенному потоку
    .subscribe((result:any) => {
      console.log(result); // Логируем результат обработки
    });
  }
```
```HTML
    <h1>Обработка двух потоков</h1>

    <button id='Mybutton'>Нажми :3</button>
```


#### 4. Как сделать несколько запросов по порядку?
Можно реализовать используя оператор concatMap(). Он позволит выполнить сначала один запрос, дождаться его завершения и начать выполнять следующий
```TS
  ngOnInit(): void {
      this.load = true
      const clickStream = fromEvent(document.getElementById('Mybutton')!, 'click')
      const freeStream = interval(1000);
  const processFunction = (data: any) => {
    return `Обработано: ${data}`;
  }

  freeStream.pipe(
    tap(() => console.log('клик по кнопке')),
    concatMap(()=> {
    return clickStream.pipe(
      tap(() => console.log('тАЙМЕР'))
    )
    })
  ).subscribe(result => {
    console.log(result)
  })
```

#### 5. Как сделать параллельные запросы?
С помощью оператора forkJoin - он возвращает ответ от потоков, как только каждый завершит свое выполнение
```TS
  forkJoin({

    clickStream: clickStream.pipe(take(1)),

    freeStream:freeStream.pipe(take(1))

  }).subscribe((result)=> {

    console.log('ответ первого запроса', result.clickStream);

    console.log('ответ второго запроса', result.freeStream)

  })
```


#### 6. Что такое Observable высшего порядка? 
###### 🎯 **Вывод**

**Observable высшего порядка** (HOO) — это `Observable`, который **эмитит другие `Observable`**, а не обычные значения.

🔹 **Для "разворачивания" HOO используйте операторы высшего порядка** (`mergeMap`, `switchMap`, `concatMap`).  
🔹 **Они помогают "сплющивать" вложенные потоки в один, чтобы упростить обработку данных.**

🚀 **Используйте HOO для сложных асинхронных операций, API-запросов и потоков пользовательских событий!**
#### 7. В чем разница между switchMap / mergeMap / concatMap?
###### switchMap -   
Обрабатывает последний приходящий запрос, игнорируя все другие. Нам не важен результат вычислений, когда пришло новое значение
```TS
switchMap(()=> {
	console.log('IN', index += 1)
	return getAsyncObs(index)
})
```
###### mergeMap -
Обрабатывает все приходящие значения асинхронно, но сохраняет их в том порядке, кто быстрее обработается. Используется когда нам обязательно нужно, чтобы запрос дошел до сервера
```TS
mergeMap(()=> {
	console.log('IN', index += 1)
	return getAsyncObs(index)
})
```

###### concatMap - 
Обрабатывает каждое приведшее значение по очереди, не приступает к следующему, пока не обработает предыдущее. Когда нужно сохранить последовательность 
```TS
concatMap(()=> {
	console.log('IN', index += 1)
	return getAsyncObs(index)
})
```

###### exhaustMap -
Игнорирует все новые пришедшие значения, пока не обработает то, с чем работает

```TS
exhaustMap(()=> {
	console.log('IN', index += 1)
	return getAsyncObs(index)
})
```
#### 8. Зачем нужно отписываться от Observable? Приведите примерны, когда отписка нужна. И когда не нужна.
Отписываться от Observable нужно, чтобы избежать утечек памяти и нежелательного поведения приложения. Это особенно важно, если Observable продолжает существовать после завершения работы компонента или сервиса, в котором он был создан

##### Когда отписка нужна
###### Бесконечные Observables
Если Observable никогда не завершает работу, например:
interval
fromEvent
Эти Observables продолжают эмитировать значения, пока на них подписаны. Если не отписаться, они будут оставаться в памяти, даже если компонент будет уничтожен.

###### События DOM (fromEvent)
Observable, привязанные к событиям DOM, такие как click или mousemove, тоже требуют отписки.

###### Созданные вручную Observables
Если вы вручную создаете Observable с помощью new Observable, он может продолжать эмитировать данные, пока не будет отписан.

##### Когда отписка не нужна
###### Короткоживущие (финализирующиеся) Observables
Observables, которые завершаются сами по себе после эмиссии данных или ошибки, не требуют ручной отписки. Например:

###### HTTP-запросы (HttpClient).
of (однократная эмиссия данных).
firstValueFrom / lastValueFrom (преобразование Observable в Promise).

###### Использование AsyncPipe
Если Observable используется в шаблоне Angular с | async, отписка выполняется автоматически. Angular сам управляет подписками.
#### 9. Как закэшировать данные в потоке?
вопрос какая то хуйня






## Subject

### 1. Что такое Subject?
Особый тип объекта в RxJS, который одновременно является и наблюдателем и издателем. Он позволяет, как отправлять данные, так и подписываться на них.

В отличие от обычных **Observables**, которые могут передавать данные только один раз (или несколько раз, но с предсказуемым поведением), `Subject` позволяет нескольким подписчикам получать данные в момент их публикации.
#### Основные особенности `Subject`:

1. **Многократные подписчики**: все подписчики получают одинаковые значения, которые отправляются через `Subject`.
2. **Мгновенная передача данных**: подписчики могут получать данные, только если подписались до того, как эти данные были опубликованы.
3. **Можно отправлять данные вручную**: вы можете явно вызывать методы, чтобы публиковать новые значения.

### 2. Какие разновидности Subject-ов вы знаете?
В RxJS есть несколько разновидностей `Subject`, каждая из которых имеет свои особенности в поведении. Вот основные из них:

#### Краткое отличие:

- **Subject** — обычный мульти-подписчик.
- **BehaviorSubject** — передает последнее значение новым подписчикам.
- **ReplaySubject** — передает несколько предыдущих значений новым подписчикам.
- **AsyncSubject** — передает только последнее значение после завершения потока.

#### Примеры:
Каждый тип имеет свою область применения в зависимости от того, как вам нужно управлять состоянием и историей данных в вашем приложении.

1. **Subject**  
    Это базовый тип `Subject`, который ведет себя как обычный мульти-подписной издатель. Все подписчики получают одинаковые значения, которые отправляются через `next()`. Однако, если подписчик подписывается после того, как данные были отправлены, он не получит их.
    
2. **BehaviorSubject**  
    Это разновидность `Subject`, которая всегда хранит последнее отправленное значение и передает его новым подписчикам при их подписке. Он всегда требует начального значения, которое будет передано первым подписчикам.  
    Пример:
```TS
import { BehaviorSubject } from 'rxjs';

const behaviorSubject = new BehaviorSubject(0);  // начальное значение 0

behaviorSubject.subscribe(value => console.log(value));  // Выведет: 0
behaviorSubject.next(1);  // Выведет: 1
behaviorSubject.subscribe(value => console.log(value));  // Выведет: 1

```

##### ReplaySubject
`ReplaySubject` сохраняет заданное количество предыдущих значений и передает их новым подписчикам при подписке. Это полезно, если вы хотите, чтобы новые подписчики получали не только текущее значение, но и некоторые предыдущие значения.
```TS
import { ReplaySubject } from 'rxjs';

const replaySubject = new ReplaySubject(2);  // Хранит последние два значения

replaySubject.next(1);
replaySubject.next(2);
replaySubject.next(3);

replaySubject.subscribe(value => console.log(value));  // Выведет: 2, 3
```

**AsyncSubject**  
`AsyncSubject` сохраняет только последнее значение, но отправляет его только когда Observable завершает свою работу (вызывается метод `complete()`). Это полезно, когда важно передать данные только после завершения потока.
```TS
import { AsyncSubject } from 'rxjs';

const asyncSubject = new AsyncSubject();

asyncSubject.subscribe(value => console.log(value));  // Сработает после завершения потока

asyncSubject.next(1);
asyncSubject.next(2);
asyncSubject.complete();  // Выведет: 2
```


### 3. Что такое горячий или холодный Observable?
В RxJS **горячий** и **холодный** Observable описывают поведение потока данных относительно того, как они управляются подписчиками.
##### Ключевые различия:

| Характеристика       | Холодный Observable                                                         | Горячий Observable                                                                             |
| -------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| **Генерация данных** | Данные генерируются при каждой подписке.                                    | Данные генерируются независимо от подписки.                                                    |
| **Подписчики**       | Каждый подписчик получает все данные с самого начала.                       | Подписчики получают данные с момента подписки, но пропускают то, что было отправлено до этого. |
| **Пример**           | Обычные `Observable` (например, через `new Observable()` или `interval()`). | `Subject`, `BehaviorSubject`, `ReplaySubject`, и т. д.                                         |
##### 1. **Холодный Observable (Cold Observable)**

- **Что это?**  
    Холодный Observable начинает генерировать данные **только тогда, когда на него подписываются**. Каждый подписчик получает свой собственный поток данных, начиная с самого первого значения.
    
- **Особенность**: Каждый подписчик получает данные с самого начала (даже если подписка произошла позже). Таким образом, каждый подписчик получает все значения потока независимо от других подписчиков.

```TS
import { Observable } from 'rxjs';

const coldObservable = new Observable(subscriber => {
  console.log('Запуск Observable');
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  subscriber.complete();
});

// Первый подписчик
coldObservable.subscribe(value => console.log(`Подписчик 1: ${value}`));

// Второй подписчик
coldObservable.subscribe(value => console.log(`Подписчик 2: ${value}`));

```
Результат:
```JSOn
Запуск Observable
Подписчик 1: 1
Подписчик 1: 2
Подписчик 1: 3
Запуск Observable
Подписчик 2: 1
Подписчик 2: 2
Подписчик 2: 3

```
##### **Горячий Observable (Hot Observable)**

- **Что это?**  
    Горячий Observable начинает генерировать данные **независимо от подписчиков**. Он не ждет, пока кто-то подпишется. Все подписчики получают данные, начиная с того момента, когда они подписываются, но не получают данные, которые были сгенерированы до этого.
    
- **Особенность**: Горячие Observables делят данные между всеми подписчиками. Например, если данные уже были отправлены, новые подписчики не получат их.
    
- **Пример:**
```TS
import { Subject } from 'rxjs';

const hotObservable = new Subject();

// Первый подписчик
hotObservable.subscribe(value => console.log(`Подписчик 1: ${value}`));

hotObservable.next(1);
hotObservable.next(2);

// Второй подписчик
hotObservable.subscribe(value => console.log(`Подписчик 2: ${value}`));

hotObservable.next(3);
```
Результат:
```yaml
Подписчик 1: 1
Подписчик 1: 2
Подписчик 2: 2
Подписчик 1: 3
Подписчик 2: 3
```


### 4. Что такое мультикастинг?

**Мультикастинг** в контексте RxJS и реактивного программирования — это техника, при которой одно и то же значение передается нескольким подписчикам, используя общий поток данных. Это противоположность **монокастингу**, где каждый подписчик получает свой собственный экземпляр потока данных.
###### Как работает мультикастинг?
Когда вы используете мультикастинг, данные передаются нескольким подписчикам одновременно, что позволяет избежать избыточных вычислений или повторной генерации данных. Мультикастинг может быть полезен, когда вам нужно разделить один поток данных между несколькими подписчиками.

```TS
  const source = new Observable(subscriber => {
    console.log('Запуск');
    subscriber.next(1);
    subscriber.next(2);
    subscriber.next(3);
    subscriber.next(4);
    subscriber.next(5);
    subscriber.next(6);
    subscriber.complete();
  });
  const testSubject =new Subject();
  testSubject.subscribe(value => console.log(`Подписчик 1: ${value}`));
  testSubject.subscribe(value => console.log(`Подписчик 2: ${value}`));
  source.subscribe(testSubject)
```
```console
Подписчик 1: 1
main-cast.component.ts:46 Подписчик 2: 1
main-cast.component.ts:45 Подписчик 1: 2
main-cast.component.ts:46 Подписчик 2: 2
main-cast.component.ts:45 Подписчик 1: 3
main-cast.component.ts:46 Подписчик 2: 3
main-cast.component.ts:45 Подписчик 1: 4
main-cast.component.ts:46 Подписчик 2: 4
main-cast.component.ts:45 Подписчик 1: 5
main-cast.component.ts:46 Подписчик 2: 5
main-cast.component.ts:45 Подписчик 1: 6
main-cast.component.ts:46 Подписчик 2: 6
```

##### Основные способы реализации мультикастинга в RxJS:

1. **Через `Subject`**: `Subject` является основным способом мультикастинга, поскольку он позволяет нескольким подписчикам слушать и получать данные из одного источника.
    
2. **Через `share()`**: Оператор `share()` создает новый Observable, который использует общий поток данных для всех подписчиков. Это позволяет избежать многократного выполнения одной и той же логики для каждого подписчика, как это происходит в случае холодных Observables.
```TS
import { of } from 'rxjs';
import { share } from 'rxjs/operators';

const shared = of(1, 2, 3).pipe(share());

shared.subscribe(value => console.log(`Подписчик 1: ${value}`));
shared.subscribe(value => console.log(`Подписчик 2: ${value}`));
```


### 5. Как убедиться, что запрос к апи пройдет лишь раз, хотя вызовов может быть несколько?


### Задача с решением
```TS
const stream$ = interval(100).pipe(take(5), map(() => Math.random()));
 
// а)
stream$.subscribe(v => console.log(v));
setTimeout(() => {
    stream$.subscribe(v => console.log(v)); 
}, 1000);
// Какие будут значения?

**Результат:**

- **Первый подписчик** начнет получать значения сразу, начиная с 0, затем через 100 мс и так далее. Он получит 5 значений с интервалом 100 мс, так как поток ограничен с помощью `take(5)`.
- **Второй подписчик** подключится через 1000 мс (по вызову через `setTimeout`), но так как `stream$` — это **холодный Observable**, второй подписчик получит свои собственные новые 5 значений, сгенерированные с момента его подписки.



// б)
stream$.subscribe(v => console.log(v));
stream$.subscribe(v => console.log(v)); 
// Какие будут значения?

**Результат:**

- Если `stream$` — это **холодный Observable**, то оба подписчика начнут получать данные с момента их подписки, и они оба получат свои собственные потоки данных. В результате оба подписчика получат **разные случайные числа**, потому что каждый из них будет иметь свою собственную генерацию случайных значений через `map(() => Math.random())`.
 
// в)
// Как сделать так, чтобы значения были одинаковые?

Чтобы оба подписчика получали одинаковые значения, нужно использовать **мультикастинг**. Один из способов — использовать `shareReplay()`. Это сохранит значения и позволит новым подписчикам получать уже сгенерированные данные, а не запускать новый поток.


const stream$ = interval(100).pipe(
  take(5),
  map(() => Math.random()),
  shareReplay(1)  // кэширует последнее значение, чтобы все подписчики получали одинаковые данные
);

stream$.subscribe(v => console.log(v));
stream$.subscribe(v => console.log(v)); 

```







# Angular

## Template-driven/Reactive Forms/Validation

### 0. [[Виды форм (template driven, reactive forms)]]

### 1. Какие подходы для построения форм имеются в Angular?
#### 1. **Reactive Forms (Реактивные формы)**

- Полный контроль над состоянием формы через TypeScript.
- Использует `FormGroup`, `FormControl` и `FormArray` для построения формы.
- Все проверки (валидации) задаются программно.
- Легко создавать динамические формы, где количество полей может изменяться.

Пример HTML разметки 
```HTML

    <form [formGroup]="form" (ngSubmit)="onSubmit()">
      <label>
        Имя:
        <input formControlName="name" />
      </label>
      <div *ngIf="form.get('name')?.invalid && form.get('name')?.touched">
        Поле "Имя" обязательно!
      </div>

      <label>
        Email:
        <input formControlName="email" />
      </label>
      <div *ngIf="form.get('email')?.invalid && form.get('email')?.touched">
        Введите корректный email!
      </div>

      <button type="submit" [disabled]="form.invalid">Отправить</button>
    </form>
```

Пример TS кода
```TS
export class ReactiveFormComponent { 
	form: FormGroup; 
	
	constructor(private fb: FormBuilder) { 
		this.form = this.fb.group({
			 name: ['', Validators.required], 
			 email: ['', [Validators.required, Validators.email]],
		}); 
	} 
	onSubmit() { console.log(this.form.value); } }
```

#### 2. Template-Driven Forms (Шаблонные формы)
Этот подход более декларативный и подходит для небольших форм с простой логикой. Основное управление осуществляется через шаблон, а не через TypeScript.
##### Особенности:

- Использует директивы Angular, такие как `ngModel`, для привязки данных.
- Меньше кода на TypeScript, управление валидацией происходит в шаблоне.
- Более прост в освоении, но менее гибкий для сложных задач.

#### 3. Dynamic Forms (Динамические формы)
Динамические формы — это расширение реактивного подхода, позволяющее динамически добавлять и изменять элементы формы. Они полезны, когда структура формы заранее неизвестна (например, количество полей определяется во время выполнения).
##### Особенности:

- Основаны на **Reactive Forms**.
- Используются для сложных сценариев, таких как формы с произвольным количеством вложенных групп или элементов.

```HTML
      <form [formGroup]="form" (ngSubmit)="onSubmit()">

        <div formArrayName="addresses">

          <div *ngFor="let address of addresses.controls; let i = index">

            <label>

              Адрес {{ i + 1 }}:

              <input [formControlName]="i" />

            </label>

            <button (click)="removeAddress(i)">Удалить</button>

          </div>

        </div>

        <button (click)="addAddress()">Добавить адрес</button>

        <button type="submit" [disabled]="form.invalid">Отправить</button>

      </form>
```

```TS
export class MainCastComponent implements OnInit {
  form: FormGroup;
  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      addresses: this.fb.array([this.fb.control('', Validators.required)]),
    });
  }

  get addresses() {
    return this.form.get('addresses') as FormArray;
  }
  
  addAddress() {
    this.addresses.push(this.fb.control('', Validators.required));
  }

  removeAddress(index: number) {
    this.addresses.removeAt(index);
  }

  onSubmit(){
    console.log(this.form.value)
  }
```




### 2. В чем различие между template-driven/reactive forms?

#### Как выбрать подход?

- **Template-Driven Forms**: Подходит для небольших, простых форм, где предпочтительна минимальная сложность.
- **Reactive Forms**: Лучше для сложных форм, где требуется высокая гибкость, динамическое добавление полей и сложные проверки.
- **Dynamic Forms**: Используется, когда структура формы полностью или частично неизвестна заранее.




### 3. Какой подход предпочитаете вы и почему?
### 4. В чем разница между *ngIf и [hidden]?

Разница между `*ngIf` и `[hidden]` в Angular заключается в том, как они управляют отображением элемента на странице и как это влияет на DOM, производительность, а также стиль реализации. Давайте разберем их детально:

#### **1. Что такое `*ngIf`?**

`*ngIf` — это структурная директива Angular, которая полностью **удаляет или добавляет элемент в DOM** на основании заданного условия.

#### **Особенности `*ngIf`:**

- Элемент **создается или удаляется** из DOM в зависимости от того, является ли условие `true` или `false`.
- Освобождает ресурсы (память и производительность), так как удаляет элемент и все связанные с ним обработчики событий, привязки данных и компоненты.
- Влияет на производительность при большом количестве элементов, так как требуется их полное добавление/удаление из DOM.

```HTML
<div *ngIf="isVisible">
  Этот текст отображается только, если isVisible === true
</div>
```

#### **2. Что такое `[hidden]`?**

`[hidden]` — это атрибут привязки, который **скрывает элемент через CSS**, добавляя или убирая свойство `hidden`.

##### **Особенности `[hidden]`:**

- Элемент **остается в DOM**, но становится невидимым, так как браузер применяет CSS `display: none;`.
- Все обработчики событий и привязки данных продолжают работать, даже если элемент скрыт.
- Полезно, когда необходимо сохранить элемент в DOM (например, чтобы сохранить его состояние).
```HTML
<div [hidden]="!isVisible">
  Этот текст скрыт через CSS, если isVisible === false
</div>
```


#### **4. Когда использовать?**

##### Используйте `*ngIf`, если:

- Вы хотите динамически добавлять или удалять элемент из DOM.
- Элемент занимает много ресурсов (например, сложные компоненты с обработчиками событий, анимациями, данными).
- Вам нужно полностью освободить ресурсы, когда элемент скрыт.

##### Используйте `[hidden]`, если:
- Вы хотите временно скрыть элемент, но сохранить его в DOM.
- Важно сохранить состояние элемента (например, значения формы или текущую позицию прокрутки).
- Элемент используется в анимациях или привязках данных.

### 5. В чем разница между компонентом и директивой?

Основная разница заключается в том, что **компоненты** являются специализированным видом директив, ориентированным на управление **шаблонами**, тогда как директивы используются для изменения поведения, структуры или внешнего вида элементов.

#### **Когда использовать?**

##### Используйте **компоненты**, если:

- Вам нужно создать часть пользовательского интерфейса с определенной логикой и представлением (например, кнопки, карточки, модальные окна).
- Элемент интерфейса будет многократно переиспользоваться.

##### Используйте **директивы**, если:

- Нужно изменить поведение или стили существующих элементов (например, подсветка, валидация, динамические стили).
- Нужно работать с существующей структурой DOM (например, добавлять/удалять элементы, как это делает `*ngIf` или `*ngFor`).

### 6. В чем разница между модулем и компонентом?
### 7. В шаблоне компонента есть элемент. Как можно получить ссылку на него в коде компонента?
#### Использование шаблонной переменной и декоратора `@ViewChild`

##### **Что это?**

- Шаблонная переменная (`#variableName`) создается в шаблоне для получения ссылки на элемент.
- Декоратор `@ViewChild` используется в коде компонента, чтобы связать эту переменную с полем класса компонента.

##### **Как это работает?**

1. В шаблоне создается переменная с помощью `#`.
2. В классе компонента используется декоратор `@ViewChild` для получения ссылки на этот элемент.


``` HTML
<input #myInput type="text" placeholder="Введите текст" />
<button (click)="focusInput()">Фокус на поле ввода</button>
```

```TS
import { Component, ElementRef, ViewChild } from '@angular/core';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
})
export class ExampleComponent {
  @ViewChild('myInput') inputRef!: ElementRef; // Получаем ссылку на элемент

  focusInput() {
    this.inputRef.nativeElement.focus(); // Устанавливаем фокус на элемент
  }
}
```

### 8. Зачем использовать Renderer если можно использовать нативные методы?

**Вывод:** Использование **`Renderer2`** — это **правильный Angular-способ** работы с DOM. Он обеспечивает:

1. Кросс-платформенность.
2. Безопасность.
3. Поддержку инкапсуляции стилей.
4. Стабильность работы Angular-приложения.
5. Удобный API для работы с DOM.

Если у вас нет веских причин использовать нативные методы, **`Renderer2`** — это лучший выбор.
### 9. Как избежать ошибок, если необходимо добавить в шаблон неизвестный элемент?

### 10. В чем разница между декораторами @ViewChild и @ContentChild?

В Angular декораторы **`@ViewChild`** и **`@ContentChild`** используются для получения доступа к элементам или компонентам в шаблоне, но они применяются для разных случаев:

- **`@ViewChild`** используется для доступа к элементам, которые определены **внутри шаблона компонента**.
- **`@ContentChild`** используется для доступа к элементам, которые передаются в компонент через **контентную проекцию (`<ng-content>`)**.

##### Используйте `@ViewChild`, если:

- Вам нужно получить доступ к элементам внутри **шаблона компонента**.
- Вы хотите управлять элементами DOM, директивами или дочерними компонентами, находящимися внутри текущего компонента.

##### Используйте `@ContentChild`, если:

- Вы хотите работать с **контентом, переданным извне** через `<ng-content>`.
- Вы хотите предоставлять компоненту гибкость, позволяя пользователю передавать произвольный контент.

### 11. В чем разница между ng-content, ng-container, ng-template?

#### 1. ng-content

##### **Что это?**

`ng-content` используется для **контентной проекции**. Он позволяет вставлять содержимое, переданное из родительского компонента, в шаблон дочернего компонента.

##### **Особенности:**

- Передает HTML-контент из родительского компонента в заданное место внутри дочернего компонента.
- Не изменяет структуру DOM и работает как "прямой слот" для вставки контента.
- Можно использовать с селекторами для управления тем, какой контент куда проецируется (мульти-слоты).

##### **Пример использования:**
```HTML
<app-card>
  <h1>Заголовок карточки</h1>
  <p>Текст карточки</p>
</app-card>
```

Дочерний компонент (шаблон):

``` HTML
<div class="card">
  <ng-content></ng-content> <!-- Сюда вставится контент -->
</div>
```

##### **Селекторы в `ng-content`:**

Вы можете использовать селекторы, чтобы вставлять разные части контента в разные места.

Дочерний компонент:
```HTML
<div class="card">
  <div class="header">
    <ng-content select="h1"></ng-content> <!-- Только заголовок -->
  </div>
  <div class="body">
    <ng-content select="p"></ng-content> <!-- Только параграф -->
  </div>
</div>

```
**Результат:**
```HTML
<div class="card">
  <div class="header">
    <h1>Заголовок карточки</h1>
  </div>
  <div class="body">
    <p>Текст карточки</p>
  </div>
</div>

```

#### 2. ng-container
##### **Что это?**

`ng-container` — это **невидимый контейнер**, который группирует элементы в шаблоне, **не создавая дополнительного элемента в DOM**. Он используется для улучшения структуры шаблона и применения директив Angular (`*ngIf`, `*ngFor` и т.д.) к группе элементов.

##### **Особенности:**

- Не отображается в DOM (не добавляет лишний `<div>` или другие элементы).
- Используется для применения директив к группе элементов или для улучшения читаемости кода.

##### **Пример использования:**

###### Без `ng-container`:
```HTML
<div *ngIf="isVisible">
  <h1>Заголовок</h1>
  <p>Текст</p>
</div>
```
В этом случае создается дополнительный `<div>` в DOM, который может быть нежелателен.
###### С `ng-container`:
```HTML
<ng-container *ngIf="isVisible">
  <h1>Заголовок</h1>
  <p>Текст</p>
</ng-container>
```

###### С `*ngFor`:
```HTML
<ng-container *ngFor="let item of items">
  <div>{{ item.name }}</div>
  <span>{{ item.value }}</span>
</ng-container>
```


#### 3. ng-template

`ng-template` используется для создания **шаблонов**, которые **не добавляются в DOM, пока они не будут явным образом отображены или использованы**. Его содержимое существует как структура Angular (инструкции, шаблон), но не рендерится в DOM по умолчанию.
##### **Особенности:**

- Сам по себе `ng-template` не виден в DOM.
- Шаблон может быть отрисован программно (с использованием `ViewContainerRef` или директив вроде `*ngIf`, `ngTemplateOutlet`).
- Используется для повторного использования шаблонов или динамической отрисовки.

###### Пример использования с `*ngIf`:
```HTML
<ng-template [ngIf]="isVisible">
  <p>Этот текст отобразится, если isVisible === true</p>
</ng-template>
```

###### Пример динамической вставки шаблона (`ngTemplateOutlet`):
```HTML 
<ng-template #myTemplate>
  <p>Это содержимое шаблона!</p>
</ng-template>

<div *ngIf="showTemplate">
  <ng-container *ngTemplateOutlet="myTemplate"></ng-container>
</div>
```
Код компонента:
```TS
export class AppComponent {
  showTemplate = true;
}
```

#### 💡 **Вывод:**

1. Используйте **`ng-content`** для вставки переданного контента (контентной проекции).
2. Используйте **`ng-container`** для группировки элементов без создания дополнительных DOM-элементов.
3. Используйте **`ng-template`** для создания шаблонов, которые могут быть рендерены программно или динамически.

### 12. Для чего нужны Pipe в Angular? Какие виды знаете и в чем их различия?

В Angular **`Pipe`** (трубы) — это мощный инструмент для преобразования данных прямо в шаблоне. Они позволяют форматировать, фильтровать или изменять данные без необходимости изменять логику компонента. Pipes используются с синтаксисом 
**`{{ выражение | pipeName }}`**.

##### **1. Для чего нужны Pipes?**

- **Форматирование данных в шаблонах.** Например, преобразование даты, числа, строки или валюты в удобочитаемый формат.
    
- **Повышение читаемости кода.** Вместо сложной логики в шаблоне данные обрабатываются с помощью Pipe, что делает шаблон более чистым и понятным.
    
- **Повторное использование логики.** Если требуется одинаковое преобразование данных в разных местах, Pipe позволяет избежать дублирования кода.

##### **Встроенные Pipes**

###### 1. **`DatePipe`**
Используется для форматирования даты.
```HTML
<p>{{ today | date:'yyyy-MM-dd' }}</p>
```

###### 2. **`CurrencyPipe`**
Форматирует число как валюту.
```HTML
<p>{{ 12345.6789 | currency:'USD':'symbol':'1.2-2' }}</p>
```

###### 3. **`DecimalPipe`**
Форматирует числа с фиксированным количеством знаков.
```HTML
<p>{{ 0.1234 | number:'1.2-3' }}</p>
```

###### 4. SlicePipe
Извлекает подстроку из массива или строки.
```HTML
<p>{{ 'Angular' | slice:0:3 }}</p>
```

5. AsyncPipe
Работает с **объектами типа Observable, Promise** и автоматически подписывается на них, упрощая асинхронную обработку данных.
```HTML
<p>{{ observableValue$ | async }}</p>
```

7. **`JsonPipe`**
Форматирует объект или массив в JSON-строку.
```HTML
<pre>{{ {name: 'Angular', version: 14} | json }}</pre>
```

##### **Пользовательские Pipes**

1. Создать кастомный pipe
2. Импортировать пайп в модулях
3. Использовать в шаблоне

##### **Когда использовать чистые и нечистые Pipes?**

Чистый пайп **запускается только при изменении ссылки** на входное значение.

- **Работает быстрее** и **не перегружает Change Detection**.
- **Не изменяет** входные данные, а только возвращает преобразованное значение.
- **Вызывается только если переданный объект изменился (новая ссылка).**

Нечистый пайп вызывается **при любом изменении в шаблоне**, даже если ссылка на входные данные **осталась той же самой**.

- Используется **при работе с массивами и объектами, которые мутируют**.
- Может **вызывать проблемы с производительностью** из-за частых вызовов.


- Используйте **чистые Pipes** для неизменяемых данных или данных, которые редко изменяются.
- Используйте **нечистые Pipes** для изменяемых данных, например, массивов, которые часто модифицируются.

##### **4. Преимущества использования Pipes**

1. **Улучшение читаемости кода.** Логика обработки данных скрыта внутри Pipe, а шаблон остается лаконичным.
    
2. **Повторное использование.** Одни и те же преобразования можно применять в разных компонентах.
    
3. **Удобство тестирования.** Pipes легко тестируются изолированно, так как они представляют собой чистую функцию.
    
4. **Интеграция с Angular.** Pipes работают синхронно с системой привязки данных Angular.


### 13. Допустим, необходимо отобразить на странице загружаемые компонентом данные. Как планируете реализовать? Какой способ реализации самый компактный? В каких случаях применяется Async Pipe?

### 14. Как с помощь template и reactive forms мгновенно выводить изменения в консоль
#### Template form
Добавить в импорт FormsModule
```HTML
<input type="text" [(ngModel)]="name" (ngModelChange)="logChange($event)" />
```

```TS
export class TestComponentComponent {
  name = '';
  logChange(value: string) {
    console.log('Изменено значение:', value);
  }
}
```

ViewChild
```HTML
<form #myForm="ngForm">
    <input type="text" name="username" ngModel />
</form>
```

```TS
export class TestComponentComponent implements AfterViewInit {
  @ViewChild('myForm') form!: NgForm
  ngAfterViewInit() {
    this.form.valueChanges?.subscribe((value)=> {
      console.log(value)
    })
  }
}
```

#### Reactive form

Можно сделать с помощью valueChanges
```HTML
<input type="text" [formControl]="nameControl" placeholder="Введите имя" />
```

```TS
  nameControl = new FormControl('');
  constructor() {
    this.nameControl.valueChanges.subscribe((value) => {
      console.log('Изменение в поле:', value);
    });
  }
```


## Routing/Guards/Resolvers

### 1. Какой механизм существует в Angular для реализации запрета перехода на страницу?

В Angular для запрета перехода на страницу используется **Route Guards** (защитники маршрутов). Они позволяют контролировать доступ к маршрутам на основе условий, таких как аутентификация, авторизация или другие бизнес-правила.

#### Основные виды Route Guards в Angular:

1. **`CanActivate`** – предотвращает переход на маршрут. - пример с аутентифицированием. Если он да - может перейти на станицу, если нет - не может. Доступ к личному кабинету
2. **`CanDeactivate`** – предотвращает выход с маршрута. Подтверждение выхода со страницы, если в форме есть несохранённые изменения.
3. **`CanLoad`** – предотвращает загрузку модуля. предотвращение загрузки модуля (пример: ленивая загрузка админки).
4. **`CanActivateChild`** – применяется к дочерним маршрутам. Разрешение доступа к разделу "админки" только для администраторов.
5. **`Resolve`** – предварительно загружает данные перед активацией маршрута.
   
   
### 2. В каких случаях предпочтительно использовать Guards, а в каких Resolvers?
#### ✅ Когда использовать **Guards**?

**Guards (`CanActivate`, `CanLoad`, `CanDeactivate`, `CanActivateChild`)** применяются для **контроля доступа** к маршрутам. Их основная задача — решить, можно ли:

- Перейти на страницу (**`CanActivate`**)
- Загрузить модуль (**`CanLoad`**)
- Выйти со страницы (**`CanDeactivate`**)
- Перейти к дочернему маршруту (**`CanActivateChild`**)

##### 🔹 Примеры использования Guards:

1. **Защита маршрута на основе аутентификации** (требуется авторизация перед входом)
2. **Проверка роли пользователя** (например, доступ только для администратора)
3. **Предотвращение выхода с формы без сохранения изменений**
4. **Запрет загрузки модуля при отсутствии прав доступа**

💡 **Когда использовать `CanLoad` вместо `CanActivate`?**

- `CanActivate` проверяет доступ **после загрузки модуля**.
- `CanLoad` предотвращает **загрузку модуля**, если доступ запрещён. Это экономит трафик, т.к. модуль вообще не загружается.

#### ✅ Когда использовать **Resolvers**?

**Resolvers (`Resolve<T>`)** применяются для **предварительной загрузки данных перед активацией маршрута**. Они нужны, чтобы:

- Гарантировать наличие данных перед рендерингом компонента.
- Исключить пустые состояния **"Загрузка..."** в компоненте.
- Улучшить UX, подготавливая всё заранее.

##### 🔹 Примеры использования Resolvers:

1. **Предзагрузка профиля пользователя перед входом в "Личный кабинет"**.
2. **Загрузка списка товаров перед открытием страницы каталога**.
3. **Получение информации о заказе перед его отображением**.

💡 **Отличие от обычного запроса в компоненте**

- Если данные загружаются в `ngOnInit()`, то при первом рендере UI может быть пустым.
- Resolver **ждёт завершения запроса** перед рендерингом страницы.

#### 🔥 Итог: **Guards vs Resolvers**

|**Функционал**|**Guards** (`CanActivate`)|**Resolvers** (`Resolve<T>`)|
|---|---|---|
|**Когда срабатывает?**|До входа на маршрут|Перед рендерингом компонента|
|**Что делает?**|Проверяет условия входа|Предварительно загружает данные|
|**Применение**|Аутентификация, авторизация, доступ к маршрутам|Получение данных до загрузки страницы|
|**Возвращает**|`true/false` (или `UrlTree` для редиректа)|`Observable` или `Promise` с данными|

##### 🚀 Рекомендации:

✔ **Используйте Guards, если вам нужно защитить маршруты от неавторизованных пользователей.**  
✔ **Используйте Resolvers, если вам нужно загрузить данные до отображения компонента, чтобы избежать пустых состояний.**

Если нужна **и защита, и предзагрузка данных**, используйте **оба механизма** одновременно. 🔥

### 3. В чем назначение и разница методов forRoot() и forChild() в RouterModule?

#### ✅ RouterModule.forRoot(routes)`

##### 📌 **Назначение**:

- Используется **только в корневом модуле** (`AppModule`).
- Определяет **основные маршруты приложения**.
- Создаёт **единственный экземпляр сервиса маршрутизации (`Router`)**, который будет использоваться во всём приложении.

##### 🛠 Когда использовать?

- В **`AppRoutingModule`** или **`AppModule`** для определения главных маршрутов приложения.

#### ✅ `RouterModule.forChild(routes)`

##### 📌 **Назначение**:

- Используется в **Lazy-Loaded или Feature модулях**.
- Определяет **дочерние маршруты**.
- Не создаёт новый экземпляр `Router`, а использует существующий из `forRoot()`.

#### 🔥 **Основные различия:**

|**Функция**|**forRoot()**|**forChild()**|
|---|---|---|
|**Где использовать?**|В `AppModule` или `AppRoutingModule`|В feature-модулях (lazy-loaded)|
|**Создаёт экземпляр `Router`?**|✅ Да (единственный для всего приложения)|❌ Нет (использует существующий)|
|**Для чего предназначен?**|Основные маршруты приложения|Дочерние маршруты внутри модулей|
|**Обязателен в приложении?**|✅ Да (должен быть в одном месте)|❌ Нет (используется по мере необходимости)|

---

#### 🎯 **Вывод**

- Используйте **`forRoot()`** в **корневом модуле** (`AppModule`) **только один раз**.
- Используйте **`forChild()`** в **Lazy-Loaded модулях** или **Feature-модулях**, чтобы добавить дочерние маршруты.
- Это помогает **разделить маршруты на логические модули** и **повысить производительность** благодаря ленивой загрузке (`lazy loading`). 🚀

### 4. В чем назначение RouterOutlet?

✅ `RouterOutlet` — это точка, где Angular **отрисовывает компоненты** по маршрутам.  
✅ Позволяет **динамически менять контент** страницы без перезагрузки.  
✅ Поддерживает **дочерние маршруты** и **множественные зоны отображения**. 🚀

##### **Как работает `RouterOutlet`?**

Когда пользователь переходит по маршруту, Angular подставляет соответствующий **компонент** внутрь `RouterOutlet`.

```TS
const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent },
];
```
### 5. Есть ли необходимость в создании Routing Module?

#### 📌 **Нужно ли создавать отдельный Routing Module в Angular?**

💡 **Ответ:** **Да, это рекомендуется** для лучшей модульности и поддержки масштабируемости. Однако, в небольших приложениях можно обойтись без него.

---

#### ✅ **Когда использовать отдельный Routing Module?**

Создание `Routing Module` даёт **преимущества**:

1. 📦 **Разделение логики маршрутизации и компонентов** – делает код чище и удобнее для поддержки.
2. ⚡ **Lazy loading (ленивая загрузка модулей)** – повышает производительность, загружая только нужные части приложения.
3. 🔄 **Переиспользуемость и инкапсуляция** – каждый модуль отвечает только за свои маршруты.
4. 👥 **Упрощает командную разработку** – маршруты и компоненты организованы отдельно.

#### 🏆 **Вывод**

✔ **Рекомендуется использовать `Routing Module`**, особенно если приложение имеет модули с ленивой загрузкой.  
✔ **Для небольших проектов** можно оставить маршруты в `AppModule`.  
✔ **Использование `Routing Module` делает код чище, удобнее и более масштабируемым**. 🚀

### 6. Как реализовать механизм отладки роутинга? (вопрос с подвохом, т.к. такой механизм уже есть).

💡 **Angular уже имеет встроенный механизм отладки маршрутизации!**  
Для этого можно использовать **Router Event Logging** и встроенный `enableTracing`. 🚀

Standalone
##### 📌 Включение отладки маршрутов в Standalone компонентах**
В Standalone приложениях `RouterModule.forRoot()` заменяется на **`provideRouter()`**, и там тоже можно передать `enableTracing: true`.
**✅ Как включить?**
В файле `main.ts` (или `bootstrap.ts` в новых проектах) добавь параметр `enableTracing: true` в `provideRouter()`:
```TS
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter, withDebugTracing } from '@angular/router';
import { AppComponent } from './app/app.component';
import { routes } from './app/routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withDebugTracing()) // Включаем трассировку роутинга
  ]
});
```

##### ✅ **Способ 1: Включение `enableTracing` (Самый быстрый способ)**

Просто добавьте `enableTracing: true` в `forRoot()` в `AppRoutingModule`.

```TS
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', loadChildren: () => import('./home/home.module').then(m => m.HomeModule) },
  { path: '**', redirectTo: '/home' }
];

@NgModule({
  imports: [
    RouterModule.forRoot(routes, { enableTracing: true }) // 👈 Включаем трассировку роутинга
  ],
  exports: [RouterModule]
})
export class AppRoutingModule {}
```

Теперь в **консоли браузера** вы увидите детальный лог всех событий роутинга, например:
```less
`NavigationStart(id: 1, url: '/home') RoutesRecognized(id: 1, url: '/home', … GuardsCheckStart(id: 1, url: '/home', … GuardsCheckEnd(id: 1, url: '/home', … ResolveStart(id: 1, url: '/home', … ResolveEnd(id: 1, url: '/home', … NavigationEnd(id: 1, url: '/home')`
```


## Lazy loading

**Lazy Loading (ленивая загрузка)** — это техника, при которой модули загружаются **только по требованию**, а не сразу при старте приложения. Это снижает размер загружаемого JavaScript и улучшает производительность. 🚀

### ✅ 1.**Когда необходимо использовать Lazy Loading?**

##### 1️⃣ **Когда приложение большое и имеет много страниц**

Если приложение состоит из **множества маршрутов**, загрузка всех модулей сразу делает старт медленным.  
🔹 **Решение:** Использовать **ленивую загрузку**, загружая только необходимые модули.

```TS
const routes: Routes = [
  { path: 'dashboard', loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule) },
  { path: 'profile', loadChildren: () => import('./profile/profile.module').then(m => m.ProfileModule) }
];
```

##### 2️⃣ **Когда есть редко используемые страницы**

Некоторые страницы открываются нечасто (**страница профиля, отчёты, настройки**).  
✔ Вместо загрузки всего при старте, они могут загружаться только **при первом заходе пользователя**.

📌 **Пример:**

- 🏠 **Главная страница** → Загружается сразу.
- ⚙ **Настройки** → Загружаются только когда пользователь открывает `/settings`.

```TS
const routes: Routes = [
  { path: '', component: HomeComponent }, // Загружается сразу
  { path: 'settings', loadChildren: () => import('./settings/settings.module').then(m => m.SettingsModule) } // Загружается лениво
];
```

##### 3️⃣ **Когда приложение имеет разные роли пользователей**

Если в приложении есть **администраторская панель**, обычным пользователям она **не нужна**.
📌 **Пример:**

- 👤 **Пользователь** → не загружает **AdminModule**
- 🛠 **Админ** → загружает **AdminModule** **только при входе в `/admin`**
```TS
const routes: Routes = [
  { path: 'admin', loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule) }
];
```

##### 4️⃣ **Когда модуль содержит тяжёлые зависимости**

Если модуль использует **большие библиотеки** (например, `Chart.js`, `D3.js`, `Google Maps`), то нет смысла загружать их сразу.

📌 **Пример:**
- 📊 **Графики (Chart.js)** → загружаются только при входе на страницу аналитики `/reports`.
```TS
const routes: Routes = [
  { path: 'reports', loadChildren: () => import('./reports/reports.module').then(m => m.ReportsModule) }
];
```


#### 🏆 **Вывод**
✔ Используйте **Lazy Loading**, если у вас **большое приложение** с несколькими модулями.  
✔ Загружайте модули **по мере необходимости** (редко используемые страницы, админ-панели).  
✔ **Оптимизируйте первую загрузку** в **SPA**.  
✔ **НЕ используйте Lazy Loading**, если приложение маленькое.

🚀 **Lazy Loading = Быстрее загрузка, меньше потребление памяти!** 🔥



### 2. Могут ли возникнуть проблемы, если модуль, в который добавлены провайдеры, загружать посредством lazy loading?

💡 **Да, могут!** Если модуль, содержащий **сервисы (провайдеры)**, загружается лениво (**Lazy Loading**), могут возникнуть проблемы с **созданием дубликатов сервисов** или **потерей состояния**. 🚨

#### 🔴 **1. Дублирование сервисов (Проблема с Singleton)**

🔹 Если сервис объявлен в **Lazy-Loaded модуле**, он **не будет Singleton** в рамках всего приложения.  
🔹 Каждый раз при загрузке этого модуля **создаётся новый экземпляр сервиса**.

🔹 **Как исправить?**

- **Перенести провайдер в `@Injectable({ providedIn: 'root' })`**
- Или **определить сервис в `AppModule`**, а не в `AdminModule`.

#### 🔴 **2. Потеря состояния при Lazy Loading**

Если модуль загружается лениво, **его сервис пересоздаётся** при каждом входе в этот модуль.

📌 **Пример проблемы:**

1. Пользователь зашёл в `/admin`, сервис `AdminService` создал данные.
2. Перешёл на `/home`. Angular **удалил `AdminModule` из памяти**.
3. Вернулся в `/admin` → **данные в сервисе сброшены** (создан новый экземпляр).

🔹 **Как исправить?**

- Использовать `providedIn: 'root'`, чтобы сервис был **глобальным**.
- Хранить данные в `localStorage` / `SessionStorage` / `NgRx` / `BehaviorSubject`.

#### 🔴 **3. Пересоздание `HttpInterceptor` и `Guards`**

🔹 Если **`HttpInterceptor` или Guard** объявлен в лениво загружаемом модуле, он может **не работать** или **создавать неожиданные эффекты**.

🔹 **Почему это проблема?**
- `HttpInterceptor` должен быть **глобальным**, но здесь он добавляется **только при загрузке `AdminModule`**.
- Если зайти на `/home`, этот интерсептор **не будет работать**.

### 3. Можно ли как-то повлиять на загрузку модулей, например, отложить на несколько секунд?
💡 **Да!** В Angular можно управлять загрузкой модулей, например:

- **Искусственно замедлить загрузку** (например, для имитации задержки сервера).
- **Загружать модули при выполнении определённых условий** (например, после аутентификации).

##### ✅ **1. Используем `loadChildren` с `delay()`**
Angular позволяет использовать **динамический импорт** в `loadChildren`, а с помощью `rxjs` можно добавить **искусственную задержку**.

📌 **Пример: Откладываем загрузку `AdminModule` на 3 секунды**
```TS
import { delay, of } from 'rxjs';

const routes: Routes = [
  { 
    path: 'admin', 
    loadChildren: () => 
      of(import('./admin/admin.module').then(m => m.AdminModule)).pipe(delay(3000)) // ⏳ Задержка 3 секунды
  }
];
```
🟢 **Когда использовать?**  
✔ Если нужно **искусственно эмулировать задержку** загрузки (например, при тестировании).

##### ✅ **2. Задержка загрузки через `CanLoad` Guard**
Можно использовать **`CanLoad`**, чтобы **контролировать, когда загружается модуль**.

📌 **Пример: Задержка 5 секунд перед загрузкой `ReportsModule`**
###### **1️⃣ Создаём `can-load.guard.ts`**
```TS
import { Injectable } from '@angular/core';
import { CanLoad } from '@angular/router';
import { delay, of, switchMap } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class CanLoadGuard implements CanLoad {
  canLoad() {
    console.log('⏳ Ждём 5 секунд перед загрузкой...');
    return of(true).pipe(delay(5000)); // ⏳ Задержка 5 секунд
  }
}
```

###### 1️⃣2    Добавляем Guard в маршруты (`app-routing.module.ts`)
```TS
const routes: Routes = [
  { 
    path: 'reports', 
    loadChildren: () => import('./reports/reports.module').then(m => m.ReportsModule),
    canLoad: [CanLoadGuard] // 👈 Задержка перед загрузкой
  }
];
```

##### ✅ **3. Загружаем модуль после выполнения API-запроса**
Можно загружать модуль **только после успешного запроса на сервер**.

📌 **Пример: Загружаем `DashboardModule`, только если сервер вернёт "success"**

###### 1️⃣ Создаём `can-load.guard.ts`
```TS
import { Injectable } from '@angular/core';
import { CanLoad } from '@angular/router';
import { Observable, of } from 'rxjs';
import { delay, map, switchMap } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';

@Injectable({
  providedIn: 'root',
})
export class CanLoadGuard implements CanLoad {
  constructor(private http: HttpClient) {}

  canLoad(): Observable<boolean> {
    return this.http.get<{ status: string }>('/api/check-dashboard-access').pipe(
      delay(2000), // ⏳ Имитация задержки сервера
      map(response => response.status === 'success') // ✅ Загружаем, если статус "success"
    );
  }
}
```




### 4. Расскажите про PreloadingStrategy
💡 **`PreloadingStrategy`** в Angular — это механизм предзагрузки модулей **в фоновом режиме** после загрузки основного приложения. Это позволяет **ускорить навигацию**, так как модули уже загружены, когда пользователь впервые на них переходит.
##### ✅ **Зачем нужна предзагрузка модулей?**

По умолчанию, если мы используем **Lazy Loading** (`loadChildren`), модуль загружается **только когда пользователь впервые открывает страницу**.  
⚠️ Это может вызывать **задержку при первом переходе**, так как Angular загружает модуль "на лету".

✔ **Решение:** Использовать **`PreloadingStrategy`**, чтобы загружать модули **автоматически в фоновом режиме** сразу после загрузки главного приложения.

### 5. Routing: Guards, базовая настройка lazy-routing
#### 🔹 1. Настроим ленивую загрузку модулей

Lazy loading позволяет загружать модули только по требованию, улучшая производительность приложения.

📌 **Пример структуры проекта**:
```arduino
/src
 ├── app
 │   ├── modules
 │   │   ├── admin
 │   │   │   ├── admin.module.ts
 │   │   │   ├── admin-routing.module.ts
 │   │   │   ├── pages
 │   │   │   │   ├── dashboard.component.ts
 │   │   │   │   ├── settings.component.ts
 │   ├── app-routing.module.ts
 │   ├── app.module.ts
```

📌 Настраиваем ленивую загрузку в `app-routing.module.ts`

```TS
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { 
    path: 'admin', 
    loadChildren: () => import('./modules/admin/admin.module').then(m => m.AdminModule) 
  },
  { path: '**', redirectTo: 'admin' } // Перенаправление на дефолтную страницу
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

#### 📌 Настраиваем маршруты для модуля `admin`

Создадим `admin-routing.module.ts` внутри `modules/admin/`:

```TS
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { DashboardComponent } from './pages/dashboard.component';
import { SettingsComponent } from './pages/settings.component';
import { AuthGuard } from '../../guards/auth.guard'; // Добавим Guard

const routes: Routes = [
  { path: '', component: DashboardComponent },
  { path: 'settings', component: SettingsComponent, canActivate: [AuthGuard] } // Защищенный маршрут
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class AdminRoutingModule { }
```

##### Создаем модуль `admin.module.ts`
```TS
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdminRoutingModule } from './admin-routing.module';
import { DashboardComponent } from './pages/dashboard.component';
import { SettingsComponent } from './pages/settings.component';

@NgModule({
  declarations: [DashboardComponent, SettingsComponent],
  imports: [CommonModule, AdminRoutingModule]
})
export class AdminModule { }
```
##### 🔹 2. Создаем Guard для защиты маршрутов
Теперь создадим **AuthGuard**, который будет проверять, авторизован ли пользователь перед переходом на страницу

```TS
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(private router: Router) {}

  canActivate(): boolean {
    const isAuthenticated = !!localStorage.getItem('token'); // Простая проверка
    if (!isAuthenticated) {
      this.router.navigate(['/login']); // Перенаправляем на страницу входа
      return false;
    }
    return true;
  }
}
```




🔹 2. Создаем Guard для защиты маршрутов
Теперь создадим **AuthGuard**, который будет проверять, авторизован ли пользователь перед переходом на страницу.


## Интеграция с backend/Interceptors

Интерсепторы (Interceptors) — это специальные классы в Angular, которые используются для перехвата HTTP-запросов и ответов, проходящих через HttpClient. Они позволяют изменять запросы перед отправкой, обрабатывать ответы, добавлять токены, перехватывать ошибки и выполнять другие задачи.

#### Основные особенности интерсепторов:

1. **Перехват HTTP-запросов и ответов**: Интерсепторы работают между клиентом и сервером, обрабатывая данные до того, как они отправляются или возвращаются.
2. **Пайплайн обработки**: Несколько интерсепторов могут быть зарегистрированы в приложении. Они обрабатываются в порядке их регистрации (в направлении запроса) и в обратном порядке (при обработке ответа).
3. **Используют RxJS**: Интерсепторы работают с потоками данных и используют `Observable`, что делает их асинхронными.
4. **Глобальный уровень**: Интерсепторы работают для всех HTTP-запросов, проходящих через `HttpClient`.

---
#### Когда использовать интерсепторы?

- **Добавление заголовков** (например, токенов авторизации).
- **Кеширование запросов**.
- **Обработка ошибок** (например, вывод сообщения о недоступности сервера).
- **Логирование HTTP-запросов и ответов**.
- **Переадресация запросов** (например, для обхода CORS-проблем).


#### 1. Каким образом в Angular можно отправить http-запрос на сервер? В чем различие между классами Http и HttpClient?

##### 🚀 HTTP-запросы в Angular: `HttpClient` vs `Http`

В Angular для работы с HTTP-запросами используется сервис **`HttpClient`** из модуля `@angular/common/http`.  
Ранее в Angular 2 использовался класс `Http` (из `@angular/http`), но он устарел и был удален с версии **Angular 6**.
##### [Предоставление `HttpClient`через внедрение зависимостей](https://angular.dev/guide/http/setup#providing-httpclient-through-dependency-injection)
```TS
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(),
  ]
};
```

`HttpClient`обеспечивается с помощью `provideHttpClient`вспомогательной функции, которую большинство приложений включают в приложение `providers`в формате `app.config.ts`.

**Итак, основное различие:**

- ✅ `HttpClient` (новый API, **использовать его**)
- ❌ `Http` (устарел и больше не поддерживается)

##### 1. Подключение `HttpClientModule`

Перед тем как отправлять запросы, нужно импортировать `HttpClientModule` в **app.module.ts**:
```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule } from '@angular/common/http'; // Добавляем модуль HTTP

import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    HttpClientModule // Подключаем HTTP-клиент
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

##### 🔹 2. Использование `HttpClient`

Теперь можно делать HTTP-запросы в сервисах или компонентах.  
Создадим сервис `api.service.ts`, который будет работать с сервером.

```TS
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  private apiUrl = 'https://jsonplaceholder.typicode.com/posts'; // Тестовый API

  constructor(private http: HttpClient) {}

  // Получение всех постов
  getPosts(): Observable<any> {
    return this.http.get(this.apiUrl);
  }

  // Получение одного поста по ID
  getPost(id: number): Observable<any> {
    return this.http.get(`${this.apiUrl}/${id}`);
  }

  // Отправка нового поста (POST)
  createPost(postData: any): Observable<any> {
    return this.http.post(this.apiUrl, postData);
  }

  // Обновление поста (PUT)
  updatePost(id: number, postData: any): Observable<any> {
    return this.http.put(`${this.apiUrl}/${id}`, postData);
  }

  // Удаление поста (DELETE)
  deletePost(id: number): Observable<any> {
    return this.http.delete(`${this.apiUrl}/${id}`);
  }
}
```

##### 🔹 3. Использование сервиса в компоненте

Теперь воспользуемся `ApiService` в компоненте, например, в `app.component.ts`.
```TS
import { Component, OnInit } from '@angular/core';
import { ApiService } from './services/api.service';

@Component({
  selector: 'app-root',
  template: `
    <h1>Список постов</h1>
    <ul>
      <li *ngFor="let post of posts">{{ post.title }}</li>
    </ul>
    <button (click)="addPost()">Добавить пост</button>
  `
})
export class AppComponent implements OnInit {
  posts: any[] = [];

  constructor(private apiService: ApiService) {}

  ngOnInit() {
    // Загружаем посты при инициализации
    this.apiService.getPosts().subscribe((data) => {
      this.posts = data;
    });
  }

  addPost() {
    const newPost = { title: 'Новый пост', body: 'Текст поста', userId: 1 };
    this.apiService.createPost(newPost).subscribe((post) => {
      console.log('Пост добавлен:', post);
      this.posts.push(post);
    });
  }
}
```




#### 2. Каким образом в Angular можно глобально управлять каждым http-запросом? Например, добавить свой заголовок.

Если нужно **глобально изменять** каждый HTTP-запрос (например, добавлять заголовки, токены, логировать запросы или обрабатывать ошибки), то **используем HTTP Interceptor**.
##### 🔹 1. Что такое `HttpInterceptor`?

`HttpInterceptor` – это специальный механизм Angular, который позволяет **перехватывать все HTTP-запросы и изменять их перед отправкой**.

Примеры использования:  
✔ Добавление **авторизационного токена**  
✔ Установка **общих заголовков**  
✔ Логирование запросов  
✔ Глобальная обработка **ошибок**

```TS
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class HttpInterceptorService implements HttpInterceptor {

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Получаем токен (например, из localStorage)
    const token = localStorage.getItem('token');

    // Клонируем запрос и добавляем заголовки
    let modifiedReq = req;
    if (token) {
      modifiedReq = req.clone({
        setHeaders: {
          Authorization: `Bearer ${token}` // Добавляем токен в заголовки
        }
      });
    }

    // Передаем измененный запрос дальше
    return next.handle(modifiedReq);
  }
}
```



#### 3. В каких случаях вы используете interceptors? Объясните принцип работы.

##### 🔹 Когда и зачем использовать `HttpInterceptor` в Angular?

**`HttpInterceptor`** – это механизм перехвата всех HTTP-запросов в Angular, который позволяет **глобально изменять запросы и ответы** без необходимости редактировать код сервисов.

##### 🔥 Когда использовать Interceptor?

✅ **Добавление заголовков (Headers)** (например, токен авторизации)  
✅ **Глобальная обработка ошибок** (например, перехват `401 Unauthorized`)  
✅ **Логирование всех HTTP-запросов** (полезно для отладки)  
✅ **Кеширование данных** (уменьшение нагрузки на сервер)  
✅ **Преобразование данных ответа** (например, изменять структуру ответа API)

##### 🔹 Как работает `HttpInterceptor`?

1️⃣ **Interceptor перехватывает каждый HTTP-запрос перед отправкой**  
2️⃣ **Можно изменить запрос (например, добавить заголовок)**  
3️⃣ **Передаем измененный запрос дальше (`next.handle(req)`)**  
4️⃣ **Когда сервер возвращает ответ, можно его модифицировать (например, обработать ошибки)**  
5️⃣ **Если используется `catchError()`, можно обработать ошибки, например, перенаправить на страницу логина при `401`**


## Lifecycle Hooks

### 1. В чем разница между конструктором и ngOnInit()? 
###### Разница между `constructor()` и `ngOnInit()` в Angular**

|🔍 **Критерий**|🚀 **constructor()**|⚡ **ngOnInit()**|
|---|---|---|
|**Когда вызывается?**|Сразу при создании компонента (до рендера)|После инициализации входных данных (`@Input()`)|
|**Как часто вызывается?**|1 раз (при создании компонента)|1 раз (после конструктора)|
|**Основная цель**|Внедрение зависимостей (Dependency Injection)|Работа с `@Input()`, подписки, HTTP-запросы|
|**Может ли работать с `@Input()`?**|❌ Нет, данные еще не переданы|✅ Да, данные уже доступны|
|**Используется для...**|- Внедрения сервисов  <br>- Создания начальных переменных  <br>- Базовой инициализации|- Запроса данных  <br>- Обработки входных данных (`@Input()`)  <br>- Подписок на `Observables`|
|**Когда используется?**|Когда не требуется работа с `@Input()`|Когда требуется `@Input()`, подписки, логика после инициализации|
|**Пример кода**|`constructor(private service: MyService) {}`|`ngOnInit() { console.log(this.inputData); }`|

✅ **Вывод**:

- **Используйте `constructor()`** для внедрения зависимостей и базовой инициализации.
- **Используйте `ngOnInit()`**, если нужно работать с `@Input()`, подписками и запросами данных. 🚀
### 2. В каком хуке вы бы реализовали очистку ресурсов/отписку от событий?
### 3. Перечислите все lifecycle hooks.
Angular предоставляет следующие хуки жизненного цикла:
1. **`ngOnChanges`**
    
    Вызывается при изменении входных (`@Input`) свойств компонента. Это первый хук, который срабатывает перед инициализацией компонента.
    
    👉 **Когда вызывается:**
    
    - Каждый раз, когда изменяются входные свойства компонента.
    - Даже перед первым вызовом `ngOnInit`.
2. **`ngOnInit`**
    
    Срабатывает один раз при инициализации компонента. Используется для выполнения кода, который должен запускаться после того, как Angular установит все свойства, включая входные (`@Input`).
    
    👉 **Когда вызывается:**
    
    - После первого вызова `ngOnChanges`.
    - Только один раз за время жизни компонента.
3. **`ngDoCheck`**
    
    Этот хук вызывается на **каждой проверке изменений** (change detection). Позволяет реализовать собственную логику отслеживания изменений.
    
    👉 **Когда вызывается:**
    
    - Каждый раз при обнаружении изменений в компоненте.
4. **`ngAfterContentInit`**
    
    Который вызывается сразу после того, как Angular впервые отобразил контент, переданный в компонент через `<ng-content>`. Он позволяет компоненту выполнять действия после того, как его проекция содержимого завершена.
    
    👉 **Когда вызывается:**
    
    - После вставки проецированного контента и первого вызова `ngDoCheck`.
5. **`ngAfterContentChecked`**
    
    Срабатывает каждый раз после проверки проецированного контента.
    
    👉 **Когда вызывается:**
    
    - После каждой проверки проецированного содержимого.
6. **`ngAfterViewInit`**
    
    Срабатывает после инициализации представления компонента и дочерних компонентов.
    Работа с элементами DOM, полученными через `@ViewChild` или `@ViewChildren`
    
    👉 **Когда вызывается:**
    
    - После рендеринга DOM-представления.

7. **`ngAfterViewChecked`**
    
    Срабатывает каждый раз после проверки представления компонента и его дочерних компонентов.
    
    👉 **Когда вызывается:**
    
    - После каждой проверки представления.
8. **`ngOnDestroy`**
    
    Вызывается перед уничтожением компонента. Используется для очистки ресурсов, таких как отписки от подписок, освобождение памяти и т. д.

При создании компонента:
1. `Constructor`
2. `ngOnChanges` (если есть входные свойства)
3. `ngOnInit`
4. `ngDoCheck`
5. `ngAfterContentInit`
6. `ngAfterContentChecked`
7. `ngAfterViewInit`
8. `ngAfterViewChecked`
При изменении данных:
1. `ngOnChanges` (если изменены `@Input`)
2. `ngDoCheck`
3. `ngAfterContentChecked`
4. `ngAfterViewChecked`
При уничтожении:
1. `ngOnDestroy`
### 4. Расскажите про ngOnChanges() hook.
`ngOnChanges` вызывается раньше `ngOnInit`, потому что Angular сначала должен обновить входные свойства компонента, чтобы компонент мог корректно работать с актуальными данными.

- **`ngOnChanges`** — реагирует на изменения данных сразу после их передачи через `@Input`.
- **`ngOnInit`** — запускается, когда все входные свойства уже установлены.

Пример последовательности:

1. Входные свойства изменяются (`@Input`).
2. Angular вызывает `ngOnChanges` для обработки новых значений.
3. Затем вызывается `ngOnInit`, чтобы можно было выполнить логику на основе установленных данных.


## Change Detection

### 1. Каким образом Change Detection работает в Angular?
##### 🔥 Как работает Change Detection (Механизм обнаружения изменений) в Angular?

**Change Detection (CD)** — это механизм, который **обнаруживает изменения в данных и обновляет DOM**, чтобы отобразить актуальное состояние приложения.

🔹 **Angular использует зону выполнения (`NgZone`) и механизм `ChangeDetectorRef` для управления обновлениями**.  
🔹 **Движок CD запускается при событиях (клики, HTTP-запросы, асинхронные операции, таймеры и т. д.)**  
🔹 **CD проверяет, изменились ли значения, и обновляет DOM только при необходимости.**

##### 🏗 Как Change Detection работает в Angular?

1️⃣  **Компонент получает новые данные (например, через `@Input()` или сервис)**  
2️⃣ **Angular запускает Change Detection автоматически**  
3️⃣ **Проверяются изменения и обновляется DOM**

💡 **Главное правило**:  
✔ **Если Angular обнаруживает изменение — оно отражается в шаблоне**  
✔ **Если данных не изменилось — ничего не обновляется**

##### 🔄 Стратегии обнаружения изменений (Change Detection Strategies)**

Angular поддерживает **две стратегии обнаружения изменений**:
###### 1️⃣ `Default` (По умолчанию)

🔹 **CD запускается при любом изменении (любое событие, таймер, HTTP-запрос и т. д.)**  
🔹 **Angular проверяет ВСЕ компоненты, даже если данные не изменились**  
🔹 **Подходит для небольших приложений, но может быть неэффективным**

📌 **Пример:**
```TS
@Component({
  selector: 'app-example',
  template: `{{ data }}`,
  changeDetection: ChangeDetectionStrategy.Default
})
export class ExampleComponent {
  @Input() data: string;
}
```
👉 **Минус `Default`**: Неоптимально, так как Angular проверяет каждый компонент при любом изменении

###### 2️⃣ `OnPush` (Оптимизированная стратегия)

🔹 **CD запускается только если изменился `@Input()` или ссылка на объект**  
🔹 **Не проверяет компонент, если его `@Input()` не изменился**  
🔹 **Работает быстрее, особенно в больших приложениях**

💡 **Когда использовать `OnPush`?**  
✔ Если данные **неизменяемые** (Immutable)  
✔ Если используете `RxJS` и асинхронные потоки  
✔ Если хотите оптимизировать производительность

👉 **Минус `OnPush`**: **Не сработает**, если изменилось **внутреннее свойство объекта**, но ссылка осталась той же.

### 2. Как можно вручную управлять механизмом Change Detection и когда это необходимо делать?

Иногда нужно **форсировать обновление вручную**. Это можно сделать с помощью `ChangeDetectorRef`.

📌 `markForCheck()` — Запускает CD в `OnPush`
```TS
import { ChangeDetectorRef } from '@angular/core';

constructor(private cdr: ChangeDetectorRef) {}

someMethod() {
  this.cdr.markForCheck(); // Запускает Change Detection
}
```

📌 `detectChanges()` — Запускает CD немедленно
```TS
this.cdr.detectChanges(); // Принудительное обновление компонента
```




### 3. В чем разница в реализации Change Detection в Angular.js и Angular?
    
     Ответ
    
    Общая концепция не изменилась. По прежнему запускается проверка , в ходе которой проверяется наличие изменений в компоненте, если да, то происходит обновление DOM.
    
    Однако, в Angular явно отсутствуют watchers (функции, которые следят за изменением модели и обновляют view), теперь это генерируется компилятором и прозрачно для пользователя. Кроме этого, слежение происходит только за конкретной моделью, т.е. один компонент имеет один watcher, который следит за всеми свойствами компонента, используемые в его шаблоне.
    
    Помимо этого, стоит учесть и работу zone.js, которая используется в Angular для перехвата асинхронных задач.
    
### 4. Встречали ли вы ошибку ExpressionChangedAfterItHasBeenCheckedError, если да, то почему она возникает и как этого можно избежать?
### 5. Какие стратегии обнаружения изменений бывают и почему лучше использовать onPush как дефолтную стратегию

1. **Default** (по умолчанию):
    - **Все компоненты проверяются**: Angular проходит по всему дереву компонентов при любом событии, изменении состояния или асинхронной операции.
    - Минусы:
        - Затратно по производительности, особенно в больших приложениях.
        - Может вызывать лишние проверки в неизменённых компонентах.
2. **OnPush**:
    - **Проверяются только компоненты с изменением данных через Input** или при использовании `ChangeDetectorRef`.
    - Проверка выполняется только при:
        - Изменении ссылки у входных данных (`@Input`).
        - Явном вызове методов `markForCheck` или `detectChanges`.
    - **Преимущества**:
        - Улучшение производительности: минимизируются проверки.
        - Код становится более предсказуемым, так как изменения должны быть явными.

**Почему лучше использовать OnPush как дефолтную стратегию?**

- Производительность выше за счёт ограничения проверок.
- Заставляет разработчиков явно управлять состоянием, что делает код чище и надёжнее.

### 6. Что такое zone.js? Для чего нужно?

- **Что это?**`zone.js` — это библиотека, которая отслеживает асинхронные операции (например, события, таймеры, HTTP-запросы) и помогает Angular автоматически запускать механизм обнаружения изменений после завершения этих операций.
- **Для чего нужен?**
    - Позволяет Angular "знать", что данные изменились, и инициировать обновление интерфейса.
    - Упрощает разработку, так как программисту не нужно вручную вызывать проверку изменений.
- **Как это работает?**`zone.js` патчит асинхронные API (например, `setTimeout`, `Promise.then`, события), и после их завершения вызывает механизм обнаружения изменений.
- Нам нужно понимать, когда началось и закончилось ассинхронное событие
### 7. Уметь использовать ChangeDetectorRef: разница между markForCheck и detectChanges.
`ChangeDetectorRef` — сервис, который предоставляет прямой контроль над обнаружением изменений в компоненте.
#### **`markForCheck`**
- Помечает компонент и его потомков для проверки при следующем цикле обнаружения изменений.
- Используется в компонентах с `OnPush` стратегией.
- Пример:
    ```TS
    this.cdRef.markForCheck();
    ```
- **Когда использовать?**
    - Если изменения произошли вне зоны действия Angular (например, данные обновились через WebSocket, а не Input).
#### **`detectChanges`**

- Немедленно инициирует проверку текущего компонента и его потомков.
- Обходит стратегию `OnPush` и запускает механизм изменения "здесь и сейчас".
- Пример:
    ```TS
    this.cdRef.detectChanges();
    ```
- **Когда использовать?**
    - Когда нужно моментально обновить отображение (например, для отображения прогресса загрузки).



## Dependency Injection
##### Что такое DI, для чего нужно, какую проблему решает?
Dependency Injection (внедрение зависимостей) — это паттерн проектирования, при котором объект получает (инжектируется) все необходимые ему зависимости извне, а не создает их самостоятельно. Другими словами, если класс A зависит от какого-либо сервиса или объекта B, то вместо того чтобы внутри себя создавать B, класс A получает уже готовый экземпляр B, например, через конструктор, сеттер или интерфейс.
###### **Для чего нужно?**

- Упрощает управление зависимостями: Angular создаёт экземпляры и управляет их жизненным циклом.
- Повышает **тестируемость**: зависимости легко заменяются на моки или фейки.
- Способствует **слабой связанности**: компоненты не создают зависимости напрямую, что улучшает поддержку и расширяемость.
###### **Какие проблемы решает?**

- Избавляет от ручного создания объектов и управления их зависимостями.
- Устраняет проблему "жёсткой зависимости" компонентов от конкретных реализаций классов.

### 1. Зачем применять Dependency Injection? Ведь можно создавать инстансы сразу там, где это необходимо?
Ключевые моменты DI:
- **Инверсия управления (IoC):**  
    Вместо того чтобы сам объект отвечал за создание своих зависимостей, эту ответственность передают внешнему компоненту (например, DI-контейнеру). Таким образом, происходит «инверсия» контроля за созданием зависимых объектов.
    
- **Слабая связанность:**  
    Поскольку объект не создает свои зависимости, он «не знает» о конкретных реализациях и может работать с любой реализацией заданного интерфейса. Это позволяет легко заменять или модифицировать зависимости без изменения кода самого объекта.
    
- **Улучшенная тестируемость:**  
    При внедрении зависимостей извне очень просто подменять реальные зависимости на моки или стаб-объекты в тестах, что значительно облегчает модульное тестирование.
    
- **Явное описание зависимостей:**  
    Передача зависимостей через конструктор или методы делает зависимости объекта явными – при взгляде на сигнатуру конструктора сразу видно, какие именно компоненты требуются для корректной работы объекта.
    
```TS
public class UserService {
    private final EmailSender emailSender;

    // Зависимость передается через конструктор
    public UserService(EmailSender emailSender) {
        this.emailSender = emailSender;
    }

    public void registerUser(User user) {
        // Используем внедренную зависимость
        emailSender.sendWelcomeEmail(user.getEmail());
    }
}
```
Здесь класс `UserService` не создает объект `EmailSender` самостоятельно, а получает его извне. Это позволяет, например, подставить другую реализацию `EmailSender` для тестирования или изменить реализацию без изменения класса `UserService`.

Таким образом, Dependency Injection помогает сделать код более гибким, модульным и легко тестируемым, уменьшая связанность между компонентами и разделяя ответственность за создание объектов и их использование.


### 2. Как реализовать сервис-синглтон?
### 3. Зачем применяется декоратор @Injectable() ?
Декоратор `@Injectable()` используется для того, чтобы пометить класс как доступный для внедрения зависимостей через механизм DI (Dependency Injection)

###### 🔥 Основные задачи `@Injectable()`
1. **Позволяет Angular распознавать класс как сервис**, который может быть внедрен в другие классы.
2. **Говорит DI-контейнеру**, что этот класс может сам зависеть от других сервисов.
3. **Позволяет управлять областью видимости (`providedIn`)**, определяя, где сервис будет доступен (на уровне всего приложения или модуля).
4. **Обеспечивает переиспользуемость кода** и улучшает модульность приложения.

```TS
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' // Регистрирует сервис на уровне всего приложения (singleton)
})
export class MyService {
  constructor() {
    console.log('MyService создан!');
  }

  getMessage() {
    return 'Hello from MyService!';
  }
}
```

```TS
import { Component } from '@angular/core';
import { MyService } from './my.service';

@Component({
  selector: 'app-example',
  template: `<p>{{ message }}</p>`,
})
export class ExampleComponent {
  message: string;

  constructor(private myService: MyService) {
    this.message = this.myService.getMessage();
  }
}
```
💡 Итог:
- **`@Injectable()` — это "подсказка" для Angular**, которая говорит: "Этот класс — сервис, и его можно внедрять".
- **Упрощает управление зависимостями**, делая код более чистым и переиспользуемым.
- **Позволяет Angular автоматически создавать и управлять сервисами** в зависимости от области видимости.

Без `@Injectable()` DI не сможет корректно работать с сервисами, особенно если они имеют зависимости! 🚀

### 4. В Angular имеется возможность задавать providers как на уровне модуля, так и на уровне компонента. В чем разница?
### 5. В чем назначение и разница методов forRoot() и forChild() в NgModule?
### 6. Что такое DI, для чего нужно, какую проблему решает?
**Dependency Injection (DI)** — это паттерн проектирования, который позволяет внедрять зависимости (например, сервисы, классы) в другие компоненты или сервисы.
#### **Для чего нужно?**

- Упрощает управление зависимостями: Angular создаёт экземпляры и управляет их жизненным циклом.
- Повышает **тестируемость**: зависимости легко заменяются на моки или фейки.
- Способствует **слабой связанности**: компоненты не создают зависимости напрямую, что улучшает поддержку и расширяемость.

#### **Какие проблемы решает?**

- Избавляет от ручного создания объектов и управления их зависимостями.
- Устраняет проблему "жёсткой зависимости" компонентов от конкретных реализаций классов.
### 7. Как инжектировать angular сервис в компонент?
Инъекция сервиса выполняется с помощью конструктора компонента.
### 8. Иерархичность дерева инжекторов
#### **Как работает дерево инжекторов?**

**Дерево инжекторов** — это структура, в которой **дочерние инжекторы могут переопределять или наследовать зависимости от родительских**.

#### Как это работает?

1. **Если Angular не находит зависимость в текущем инжекторе**, он поднимается вверх по дереву.
2. **Если зависимость найдена — она возвращается**.
3. **Если не найдена и на верхнем уровне — Angular выбрасывает ошибку**.

🔹 **Поиск начинается снизу и поднимается вверх**  
🔹 **Сервис может быть переопределен на любом уровне**

1. **Рутовый инжектор**:
    - Создаётся при загрузке приложения.
    - Включает все зависимости с `providedIn: 'root'`.
2. **Инжекторы компонентов и модулей**:
    - Каждый компонент/модуль может иметь собственный инжектор.
    - Если зависимость не найдена на локальном уровне, Angular ищет её в родительских инжекторах (вплоть до рутового).
```TS
@Component({
  selector: 'parent',
  template: '<child></child>',
  providers: [ParentService],
})
export class ParentComponent {}

@Component({
  selector: 'child',
  template: '<p>Child works!</p>',
})
export class ChildComponent {
  constructor(private parentService: ParentService) {} // Инжекция возможна
}
```


### 9. Injection token'ы
##### 🚀 Injection Tokens в Angular

В Angular **Injection Token** – это механизм для создания и внедрения зависимости, когда **стандартные классы не подходят**. Он особенно полезен, если нужно **передавать нестандартные объекты**, такие как **конфигурации, глобальные переменные или динамически создаваемые данные**.

###### Использование:

1. Создание токена:
```TS
import { InjectionToken } from '@angular/core';
export const API_URL = new InjectionToken<string>('API_URL');
```

Регистрация зависимости:
```TS
providers: [
  { provide: API_URL, useValue: 'https://api.example.com' },
],
```

Инжекция через конструктор:
```TS
constructor(@Inject(API_URL) private apiUrl: string) {
  console.log(this.apiUrl); // 'https://api.example.com'
}
```


##### 🔹 Зачем нужны Injection Tokens?

✔ **Используются для внедрения объектов, не являющихся классами**  
✔ **Позволяют передавать динамические данные в DI-контейнер**  
✔ **Позволяют заменять стандартные сервисы кастомными**  
✔ **Используются для глобальной конфигурации приложения**

##### 🔹 Как создать `InjectionToken`?

###### ✅ 1. Простой пример: глобальная конфигурация

Допустим, у нас есть объект с конфигурацией API:
🔹 Создаём `app.config.ts`

```TS
export const APP_CONFIG = {
  apiUrl: 'https://api.example.com',
  featureFlag: true
};
```

###### **🔹 Создаём `InjectionToken`**

В файле `config.token.ts` создадим токен:
```TS
import { InjectionToken } from '@angular/core';
export const APP_CONFIG_TOKEN = new InjectionToken('app.config');
```

###### **🔹 Используем токен в компоненте**

Теперь можно **внедрить** этот токен в `AppComponent`
```TS
import { Component, Inject } from '@angular/core';
import { APP_CONFIG_TOKEN } from './config.token';

@Component({
  selector: 'app-root',
  template: `<h1>API URL: {{ config.apiUrl }}</h1>`
})
export class AppComponent {
  constructor(@Inject(APP_CONFIG_TOKEN) public config: any) {
    console.log('Конфигурация:', config);
  }
}
```

###### 🔹 2. Использование Injection Token с фабрикой

Иногда нам нужно **создавать зависимости динамически**. Например, **получать API URL из `environment.ts`**.

Создаём токен с фабрикой
```TS
import { InjectionToken } from '@angular/core';
import { environment } from '../environments/environment';

export const API_URL = new InjectionToken<string>('api.url', {
  providedIn: 'root',
  factory: () => environment.apiUrl
});
```

еперь можно **внедрять** `API_URL` без необходимости добавлять его в `providers[]`:
```TS
import { Component, Inject } from '@angular/core';
import { API_URL } from './api.token';

@Component({
  selector: 'app-root',
  template: `<h1>API URL: {{ apiUrl }}</h1>`
})
export class AppComponent {
  constructor(@Inject(API_URL) public apiUrl: string) {}
}
```

🔹 3. Использование Injection Token с классами
Иногда нам нужно **заменить сервис кастомной реализацией**.
##### Создаём интерфейс
```TS
export interface Logger {
  log: (message: string) => void;
}
```

Создаём `InjectionToken`
```TS
import { InjectionToken } from '@angular/core';
import { Logger } from './logger.interface';

export const LOGGER_TOKEN = new InjectionToken<Logger>('LoggerService');
```

##### 🎯 Итог: Когда использовать Injection Tokens?

✔ **Глобальная конфигурация (API, флаги фичей, ключи)**  
✔ **Внедрение нестандартных объектов (не классов)**  
✔ **Замена сервисов в зависимости от окружения**  
✔ **Создание динамических зависимостей**

💡 **Injection Tokens – мощный инструмент, который делает DI в Angular ещё гибче!** 🚀

### 10. useClass, useValue, useFactory
В **Angular** механизм **Dependency Injection (DI)** позволяет гибко управлять зависимостями через провайдеры (`providers`).  

Я бы мог назвать это синтаксическим сахаром. Условно, если у нас есть один сервис, но мы хотим сделать его в нескольких вариациях, то будет проще наследовать через extends его эти вариации, чем создавать несколько методов. Это работает с useClass и useValue, но как корректно и практично использовать useFactory я не додумался.

Основные способы задания зависимости:
- ✅ `useClass` – указывает **класс**, который будет использоваться для создания зависимости
- ✅ `useValue` – передаёт **готовый объект или примитив**
- ✅ `useFactory` – создаёт объект **динамически через функцию-фабрику**

Все три способа позволяют гибко управлять зависимостями и конфигурацией сервисов в **Angular 19**. 🚀

##### 📌 `useClass`: внедрение классов
Используется, если у нас **есть интерфейс и несколько реализаций**, и мы хотим подменять их.
🔹 1️⃣ Создадим интерфейс
```TS
export interface Logger {
  log(message: string): void;
}
```
🔹 2️⃣ Создадим два класса-логгера
```TS
export class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log('ConsoleLogger:', message);
  }
}

export class FileLogger implements Logger {
  log(message: string): void {
    console.log('FileLogger:', message); // Имитация логирования в файл
  }
}
```

🔹 3️⃣ Регистрируем в `providers[]`
В файле **`app.module.ts`**:
```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { Logger } from './logger.interface';
import { ConsoleLogger, FileLogger } from './logger.service';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [
    { provide: Logger, useClass: ConsoleLogger } // Меняйте на FileLogger для теста
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

🔹 4️⃣ Используем в компоненте
```TS
import { Component } from '@angular/core';
import { Logger } from './logger.interface';

@Component({
  selector: 'app-root',
  template: `<button (click)="logMessage()">Логировать</button>`
})
export class AppComponent {
  constructor(private logger: Logger) {}

  logMessage() {
    this.logger.log('Привет из Angular!');
  }
}
```

✅ **Теперь можно легко менять логгер, просто поменяв `useClass: ConsoleLogger` на `FileLogger` в `providers[]`.**

##### 📌 `useValue`: внедрение объектов и примитивов

🔹 1️⃣ Создадим объект конфигурации
```TS
export const APP_CONFIG = {
  apiUrl: 'https://api.example.com',
  debugMode: true
};
```

🔹 2️⃣ Создадим `InjectionToken`
```TS
import { InjectionToken } from '@angular/core';

export const APP_CONFIG_TOKEN = new InjectionToken('app.config');
```

🔹 3️⃣ Регистрируем `useValue`
```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { APP_CONFIG, APP_CONFIG_TOKEN } from './config.token';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [
    { provide: APP_CONFIG_TOKEN, useValue: APP_CONFIG } // Передаём объект
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

🔹 4️⃣ Используем в компоненте
```TS
import { Component, Inject } from '@angular/core';
import { APP_CONFIG_TOKEN } from './config.token';

@Component({
  selector: 'app-root',
  template: `<h1>API URL: {{ config.apiUrl }}</h1>`
})
export class AppComponent {
  constructor(@Inject(APP_CONFIG_TOKEN) public config: any) {}
}
```
✅ Теперь **конфигурация доступна глобально**, и её можно легко изменять.

##### 📌 `useFactory`: создание объекта через фабрику
Используется, если **нужно создавать объект динамически** (например, загружать конфигурацию в зависимости от окружения).

Используется, если **нужно передавать конфигурации**, константы или глобальные параметры.
🔹 1️⃣ Создадим фабрику
```TS
export function configFactory() {
  return {
    apiUrl: window.location.hostname.includes('localhost') 
      ? 'http://localhost:3000' 
      : 'https://api.example.com'
  };
}
```

🔹 2️⃣ Регистрируем в `providers[]`
```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { APP_CONFIG_TOKEN } from './config.token';
import { configFactory } from './config.factory';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [
    { provide: APP_CONFIG_TOKEN, useFactory: configFactory }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

🔹 3️⃣ Используем в компоненте
```TS
import { Component, Inject } from '@angular/core';
import { APP_CONFIG_TOKEN } from './config.token';

@Component({
  selector: 'app-root',
  template: `<h1>API URL: {{ config.apiUrl }}</h1>`
})
export class AppComponent {
  constructor(@Inject(APP_CONFIG_TOKEN) public config: any) {}
}
```
✅ Теперь **API URL определяется автоматически** в зависимости от окружения (`localhost` или продакшен).

##### 🎯 Итог: Когда использовать?

|Подход|Когда использовать?|Пример|
|---|---|---|
|**useClass**|Если нужно внедрить **класс** (сервис, логгер)|`useClass: ConsoleLogger`|
|**useValue**|Если нужно передать **объект или примитив**|`useValue: { apiUrl: '...' }`|
|**useFactory**|Если объект должен создаваться **динамически**|`useFactory: () => { return { apiUrl: '...' } }`|

✅ `useClass` – **если у вас сервисы с разными реализациями**  
✅ `useValue` – **если передаёте конфигурации, глобальные настройки**  
✅ `useFactory` – **если создание объекта зависит от условий (динамическая логика)**

🔥 **Теперь вы умеете гибко управлять зависимостями в Angular через DI!** 🚀
### 11. Optional, SkipSelf, Inject DI-декораторы

В **Angular Dependency Injection (DI)** есть специальные декораторы, которые помогают контролировать поведение внедрения зависимостей. Сегодня разберём три важных декоратора:

|Декоратор|Описание|
|---|---|
|`@Optional()`|Позволяет **не выбрасывать ошибку**, если зависимость отсутствует|
|`@SkipSelf()`|Ищет зависимость **в родительском инжекторе**, игнорируя текущий|
|`@Inject()`|Позволяет явно указать, **какой токен использовать** для внедрения|
##### 3️⃣ `@Inject()`: Явное указание токена

Обычно Angular **автоматически** определяет, какой сервис внедрять.  
Но если **инъекция сложная** (например, когда используем `InjectionToken`), нужно `@Inject()`.
###### 🔹 Пример с `InjectionToken`

Создадим **InjectionToken** для API-конфигурации:
```TS
import { InjectionToken } from '@angular/core';

export const API_URL = new InjectionToken<string>('api.url');
```

Теперь зарегистрируем его в `app.module.ts`:
```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { API_URL } from './api.token';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [
    { provide: API_URL, useValue: 'https://api.example.com' }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

Теперь **внедрим его вручную с `@Inject()`**:
```TS
import { Component, Inject } from '@angular/core';
import { API_URL } from './api.token';

@Component({
  selector: 'app-root',
  template: `<h1>API URL: {{ apiUrl }}</h1>`
})
export class AppComponent {
  constructor(@Inject(API_URL) public apiUrl: string) {}
}
```
✅ Теперь **API URL передаётся через DI**, даже если он **не класс, а строка**.

##### Когда использовать `@Inject`?

- **Токены**: Если вы используете строковые или другие кастомные токены, `@Inject` обязателен.
- **Примитивные значения**: Если вам нужно инжектировать примитивные значения (например, строки, числа), используйте `@Inject` с токенами.
- **Абстракции и интерфейсы**: Если вы хотите инжектировать зависимости, основанные на абстракциях или интерфейсах, `@Inject` помогает указать, какую конкретную реализацию нужно использовать.

##### 🎯 Итог: когда использовать?

|Декоратор|Когда использовать?|Пример|
|---|---|---|
|`@Optional()`|Если зависимость **может отсутствовать**|`@Optional() private logger?: LoggerService`|
|`@SkipSelf()`|Если **нужно искать зависимость только в родительском инжекторе**|`@SkipSelf() private logger: LoggerService`|
|`@Inject()`|Когда Angular **не может автоматически определить токен**|`@Inject(API_URL) public apiUrl: string`|

### Инстансы
##### 🔹 Про создание инстансов

1️⃣ **Инстанс = созданный экземпляр класса** (компонента, сервиса, директивы).  
2️⃣ **Компоненты создаются при рендеринге и уничтожаются при удалении из DOM**.  
3️⃣ **Сервисы по умолчанию – singleton (`providedIn: 'root'`)**, но можно делать **новые инстансы через `providers: []` в компоненте**.  
4️⃣ **Директивы и пайпы также создают свои инстансы при использовании**.

🔥 **Angular сам управляет жизненным циклом инстансов, но можно контролировать их через DI!** 🚀

В **Angular** под **инстансом (instance)** чаще всего понимают **экземпляр класса**, созданный при его инициализации. Инстансы создаются через **Dependency Injection (DI)** и управляются Angular.

При первом появлении `<app-test></app-test>` в шаблоне, Angular:  
1️⃣ **Создает инстанс `TestComponent`**  
2️⃣ **Вызывает его `constructor`**  
3️⃣ **Вызывает `ngOnInit()`** (если реализован)  
4️⃣ **Добавляет в DOM**
🔹 **Если компонент удаляется из DOM, Angular уничтожает его инстанс (`ngOnDestroy()`)**.

✔ **Если сервис зарегистрирован в `providedIn: 'root'`, то он будет единственным инстансом для всего приложения**.
```TS
constructor(private myService: MyService) {}
```
- `MyService` создается **один раз**.
- Любой компонент или сервис, который его использует, получает **тот же инстанс**.

#####🔹 Как создать несколько инстансов сервиса?**

Чтобы **НЕ использовать singleton**, можно зарегистрировать сервис **локально** в компоненте:
```TS
@Component({
  selector: 'app-child',
  standalone: true,
  providers: [MyService], // 👈 Новый инстанс для каждого компонента
  template: `...`,
})
export class ChildComponent {
  constructor(private myService: MyService) {}
}
```
Теперь каждый `<app-child>` создаст новый инстанс `MyService`!

##### Жизненный цикл инстансов в Angular 🔄

В **Angular** каждый инстанс (экземпляр класса) проходит определенные **этапы жизни**:  
1️⃣ **Создание (Instantiation)**  
2️⃣ **Инициализация (Initialization)**  
3️⃣ **Обновление (Change Detection & Updates)**  
4️⃣ **Удаление (Destruction)**

Разберем, как это происходит для **компонентов** и **сервисов**.
Компонент – это обычный класс TypeScript, но его инстанс управляется **Angular**.  
Он создается и уничтожается в зависимости от его наличия в шаблоне.

##### Компонент
###### 📌 Этап 1. Создание

🔹 Когда Angular встречает компонент в шаблоне (`<app-test></app-test>`), он:  
✔ **Создает инстанс класса компонента** (вызывает `constructor()`).  
✔ **Разрешает зависимости (`Dependency Injection`)**, если они есть.  
✔ **Вызывает методы жизненного цикла** (`ngOnInit()`, `ngAfterViewInit()`, и т. д.).

###### 📌 Этап 2. Инициализация

После создания Angular выполняет **инициализацию данных**:

1️⃣ `ngOnChanges(changes: SimpleChanges)` – вызывается, если компонент получает `@Input()` свойства.  
2️⃣ `ngOnInit()` – вызывается **один раз**, когда компонент полностью инициализирован.  
3️⃣ `ngAfterViewInit()` – вызывается, когда шаблон полностью загружен.

###### 📌 Этап 3. Обновление

Angular **следит за изменениями данных** и обновляет шаблон.

1️⃣ `ngDoCheck()` – вызывается при каждом **изменении состояния**.  
2️⃣ `ngAfterContentChecked()` – срабатывает после обновления `ng-content`.  
3️⃣ `ngAfterViewChecked()` – вызывается после обновления шаблона.

###### 📌 Этап 4. Удаление

Если компонент **удаляется из DOM**, Angular:  
✔ **Вызывает `ngOnDestroy()`**  
✔ **Удаляет инстанс из памяти**  
✔ **Завершает подписки и таймеры** (если это не сделать – утечка памяти!)


##### Сервис

🔹 **Сервисы живут дольше, чем компоненты!**

- Если сервис **синглтон (`providedIn: 'root'`)**, он создается **один раз** на всё приложение.
- Если сервис **локальный (`providers: [Service]` в компоненте)**, его инстанс создается **только для этого компонента**.












## Standalone

1. Что такое standalone компонент?
    
     Ответ
    
    Standalone - новый способ компоновки директив, компонент, пайпов. Такой тип «элемента» позволяет указывать свои зависимости напрямую, а не получать их через NgModule, и не требует декларировать себя где-то.
    
2. С внедрением standalone отпала необходимость в модулях, что стало с модульной иерархией injector-ов?
    
     Ответ
    
    Она осталась такой же, но ее инжекторы стали называться инжекторами окружения (environment injectors)
    
3. В чем отличие environment injector-ов от старых модульных?
    
     Ответ
    
    Они могу выполнять дополнительную логику при инициализации через ENVIRONMENT_INITIALIZER. Других отличий нет
    
4. В каких еще случаях создается environment injector?
    
     Ответ
    
    Lazy loading модулей/stanadlone компонентов, при указании провайдеров через свойство providers в роутах.


## Работа DI/injectors

1. В чем отличие между provideIn: ‘root’ и providedIn ‘any’?
    
     Ответ
    
    В случае отсутствия lazy модулей отличий нет, иначе каждый отдельный lazy-модуль будет получать свой собственный инстанс сервиса.
    
2. Что произойдет, если в один инжектор попадет объявление нескольких провайдеров для одного токена? Продолжение вопроса – можно ли передать несколько провайдеров под одним токеном?
    
     Ответ
    
    Последний провайдер перезапишет предыдущий. 2- Да, нужно объявить их с аргументов multi: true
    
3. Что такое viewProviders в свойствах декоратора Component? В чем отличие от providers?
    
     Ответ
    
    Внутри «темплейта» компонента существует два вида элементов: «родные» view и переданные сверху content-элементы. Для ограничения передачи зависимостей последним используется viewProviders.


## [[События и директивы]] двусторонняя привязка
## [[Control Flow]]

## Как написать свой пайп?
В Angular пайпы используются для преобразования данных в шаблонах. Создание собственного пайпа — это мощный способ настроить обработку данных под ваши нужды. Давайте разберем шаги для создания и использования пользовательского пайпа.

##### 1. **Создание файла для пайпа**

Вы можете использовать Angular CLI, чтобы быстро создать новый пайп:
```TS
ng generate pipe capitalize
```
Этот процесс создаст два файла:
- `capitalize.pipe.ts`
- `capitalize.pipe.spec.ts` (тестовый файл)

##### 2. **Реализация логики в пайпе**

Откройте файл `capitalize.pipe.ts`. Вот пример, как реализовать пайп для преобразования строки в формат с заглавной буквы:

```TS
import { Pipe, PipeTransform } from '@angular/core';
@Pipe({
  name: 'capitalize'
})
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    if (!value) return '';
    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
  }
}
```

###### Разбор:

- Декоратор `@Pipe` указывает Angular, что это пайп. Параметр `name` задаёт имя пайпа, используемое в шаблонах.
- Класс `CapitalizePipe` реализует интерфейс `PipeTransform`, который требует метода `transform()`.a
##### 3. **Регистрация пайпа**

Добавьте созданный пайп в массив `declarations` модуля, где он будет использоваться. Например, в файле `app.module.ts`:

```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { CapitalizePipe } from './capitalize.pipe'; // Импорт вашего пайпа

@Component({

  selector: 'app-test-component',

  imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule, CapitalizePipe ],

  templateUrl: './test-component.component.html',

  styleUrl: './test-component.component.css',

})
```

### 4. **Использование пайпа**

Теперь вы можете использовать ваш пайп в шаблоне. Например:
```HTML
<p>{{ 'angular' | capitalize }}</p>
```

## Санитазинг и безопасность контента

В веб-разработке **санитайзинг (sanitization)** используется для предотвращения атак, таких как **XSS (Cross-Site Scripting)**.  
Angular **автоматически** защищает ваш код, но иногда вам нужно управлять безопасностью вручную.

##### 🔹 Автоматический санитайзинг в Angular

Angular использует **DOMSanitizer** для очистки (`sanitize`) потенциально опасного HTML, URL, стилей и скриптов.

##### Как работает встроенный механизм безопасности?

|Тип контента|Авто-санитайзинг?|Пример|
|---|---|---|
|**HTML (`innerHTML`)**|✅ Очищает скрипты, опасные теги|`<script>`, `<iframe>` удаляются|
|**URL (`[href]`, `[src]`)**|✅ Блокирует небезопасные ссылки|`javascript:alert('XSS')` не выполнится|
|**CSS (`[style]`)**|✅ Удаляет опасные inline-стили|`expression()` запрещён|
|**Scripts (`<script>`)**|🚫 Запрещено полностью|Angular не позволяет `<script>`|
##### 🔹 Когда нужно вручную санитайзить контент?

Иногда вам нужно **разрешить безопасный контент**, например:

- **Вывести HTML-код из базы данных**
- **Использовать iframe или YouTube-видео**
- **Добавить безопасный URL (blob, data:)**
- **Использовать стили динамически**

Для этого в Angular есть **`DomSanitizer`**.
##### 🔹 Использование `DomSanitizer`

`DomSanitizer` позволяет **вручную указывать**, что контент безопасен.
Пример: разрешаем безопасный HTML
```TS
import { Component } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

@Component({
  selector: 'app-root',
  template: `<div [innerHTML]="safeHtml"></div>`
})
export class AppComponent {
  safeHtml: SafeHtml;

  constructor(private sanitizer: DomSanitizer) {
    const dangerousHtml = `<h2 style="color:red">Привет</h2> <script>alert('XSS')</script>`;
    this.safeHtml = this.sanitizer.bypassSecurityTrustHtml(dangerousHtml);
  }
}
```
✅ **Angular разрешит теги, но удалит `<script>`**

🔹 Разрешаем безопасные URL
📌 **Пример: Разрешаем ссылку на YouTube**
```TS
import { Component } from '@angular/core';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';

@Component({
  selector: 'app-video',
  template: `<iframe [src]="safeUrl" width="600" height="400"></iframe>`
})
export class VideoComponent {
  safeUrl: SafeResourceUrl;

  constructor(private sanitizer: DomSanitizer) {
    const videoUrl = 'https://www.youtube.com/embed/dQw4w9WgXcQ';
    this.safeUrl = this.sanitizer.bypassSecurityTrustResourceUrl(videoUrl);
  }
}
```

##### 🔹 Полный список методов `DomSanitizer`

|Метод|Для чего?|Пример|
|---|---|---|
|`bypassSecurityTrustHtml(html)`|Разрешает HTML-код|`innerHTML`|
|`bypassSecurityTrustScript(script)`|Разрешает скрипты (не рекомендуется!)|`<script>` (ОПАСНО!)|
|`bypassSecurityTrustStyle(style)`|Разрешает inline-стили|`[style]`|
|`bypassSecurityTrustUrl(url)`|Разрешает URL|`[href]`, `[src]`|
|`bypassSecurityTrustResourceUrl(url)`|Разрешает ресурсы|`<iframe src="">`|

## Input/Output

@Input: Используется для передачи данных от родительского компонента в дочерний. Позволяет родительскому компоненту устанавливать значения в дочерний.

```TS
@Component({
  selector: 'child-component',
  template: `<p>Received: {{data}}</p>`,
})
export class ChildComponent {
  @Input() data!: string;
}


@Component({
  selector: 'app-root',
  template: `<child-component [data]="parentData"></child-component>`,
})
export class AppComponent {
  parentData = 'Hello, Child!';
}
```

@Output: Используется для передачи событий из дочернего компонента в родительский. Обычно это объект EventEmitter.

```TS
@Component({
  selector: 'child-component',
  template: `<button (click)="sendData()">Send</button>`,
})
export class ChildComponent {
  @Output() event = new EventEmitter<string>();
  sendData() {
    this.event.emit('Data from child');
  }
}

@Component({
  selector: 'app-root',
  template: `<child-component (event)="receiveData($event)"></child-component>`,
})
export class AppComponent {
  receiveData(data: string) {
    console.log(data);
  }
}
```



# TypeScript
## **Типы данных в TypeScript**

**TypeScript** расширяет JavaScript, добавляя строгую типизацию. Это помогает избежать ошибок на этапе компиляции и делает код более предсказуемым.

---

### **1️⃣ Примитивные типы**

Это базовые типы данных, которые есть в JavaScript и TypeScript.

|**Тип**|**Описание**|**Пример**|
|---|---|---|
|`string`|Строки|`let name: string = "Angular";`|
|`number`|Числа (целые и дробные)|`let age: number = 25;`|
|`boolean`|Логический тип (`true` или `false`)|`let isAdmin: boolean = true;`|
|`null`|Отсутствие значения|`let empty: null = null;`|
|`undefined`|Неопределенное значение|`let notAssigned: undefined = undefined;`|
|`bigint`|Большие числа (ES2020+)|`let big: bigint = 9007199254740991n;`|
|`symbol`|Уникальные идентификаторы|`let uniqueKey: symbol = Symbol("id");`|

---

### **2️⃣ Объектные (структурные) типы**

TypeScript поддерживает сложные структуры данных.

#### **2.1 Массивы (`Array`)**

```TS
let numbers: number[] = [1, 2, 3]; 
let strings: Array<string> = ["Angular", "React"];
```

---

#### **2.2 Кортежи (`Tuple`)**

Кортежи позволяют определять массив с фиксированным количеством элементов разного типа.

```TS
let person: [string, number] = ["Alice", 30];
```

---

#### **2.3 Объекты (`Object`)**

```TS
let user: { name: string; age: number } = { name: "John", age: 25 };
```

---

#### **2.4 Enum (Перечисления)**

Перечисления создают именованные константы.

```TS
enum Role {
  Admin, // 0
  User,  // 1
  Guest  // 2
}

let myRole: Role = Role.Admin;
console.log(myRole); // 0
```

Можно задать свои значения:

```TS
enum Status {
  Success = 200,
  NotFound = 404
}
```

---

### **3️⃣ Специальные типы**

|**Тип**|**Описание**|**Пример**|
|---|---|---|
|`any`|Отключает типизацию (может быть любым)|`let data: any = 42; data = "hello";`|
|`unknown`|Аналог `any`, но требует проверки типа перед использованием|`let value: unknown;`|
|`void`|Используется в функциях, которые ничего не возвращают|`function log(): void { console.log("Hi"); }`|
|`never`|Используется для функций, которые никогда не завершаются (ошибки, бесконечные циклы)|`function error(): never { throw new Error("Error"); }`|

---

### **4️⃣ Расширенные (дополнительные) типы**

#### **4.1 Union (Объединение типов)**

Позволяет переменной принимать несколько типов.

```TS
let value: string | number;
value = "Hello"; 
value = 42;
```

---

#### **4.2 Intersection (Пересечение типов)**

Объединяет несколько типов в один.

```TS
type Person = { name: string };
type Employee = { company: string };
type Worker = Person & Employee;

let worker: Worker = { name: "Alice", company: "Google" };
```

---

#### **4.3 Type Assertions (Приведение типов)**

TypeScript позволяет явно указывать тип переменной:

```TS
let someValue: any = "Hello"; let strLength: number = (someValue as string).length;
```

---

#### **4.4 Literal Types (Литеральные типы)**

typescript

КопироватьРедактировать

```TS
let direction: "left" | "right"; direction = "left"; // 
✅ direction = "up";   // ❌ Ошибка`
```

---

### **5️⃣ Функции и их типизация**

#### **5.1 Типизация аргументов и возвращаемого значения**

```TS
function sum(a: number, b: number): number {
  return a + b;
}
```

#### **5.2 Опциональные параметры**

```TS
function greet(name: string, age?: number) {
  console.log(`Hello, ${name}`);
}
```

---

### **🛠 Итог**

TypeScript предлагает строгую типизацию с возможностью контроля типов данных.

- **Примитивные типы:** `string`, `number`, `boolean`, `null`, `undefined`, `bigint`, `symbol`.
- **Объектные типы:** `Array`, `Tuple`, `Object`, `Enum`.
- **Специальные типы:** `any`, `unknown`, `void`, `never`.
- **Расширенные типы:** `union`, `intersection`, `type assertion`, `literal types`.

**TypeScript помогает сделать код более предсказуемым и безопасным! 🚀**
1. Decorators
2. Custom Types
3. Enums
4. tsconfig

## Модификаторы доступа в TS

Модификаторы доступа (**Access Modifiers**) определяют, какие части кода могут обращаться к свойствам и методам класса. В TypeScript есть три основных модификатора:

- `public`
- `private`
- `protected`

Также есть `readonly`, который не относится к уровню доступа, но ограничивает возможность изменения свойств.

## Ключевое слово `static` в TypeScript
Ключевое слово `static` позволяет создавать **статические свойства и методы**, которые принадлежат **не объекту (экземпляру)** класса, а самому **классу**.

📌 **Обычные (нестатические) свойства и методы привязаны к объектам класса.**  
📌 **Статические свойства и методы привязаны к самому классу и вызываются без создания экземпляра.**